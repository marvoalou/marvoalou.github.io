<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo</title>
      <link href="/posts/37733.html"/>
      <url>/posts/37733.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-美化记录"><a href="#Hexo-美化记录" class="headerlink" title="Hexo 美化记录"></a>Hexo 美化记录</h2><p>页脚养鱼：<br>footer.styl<br><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: <span class="built_in">alpha</span>(<span class="variable">$dark</span>-black, .<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer-wrap</span></span><br><span class="line">   <span class="attribute">position</span>: absolute</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">1.2rem</span> <span class="number">1rem</span> <span class="number">1.4rem</span></span><br><span class="line">   <span class="attribute">color</span>: <span class="variable">$light</span>-grey</span><br><span class="line">   <span class="attribute">text-align</span>: center</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">   <span class="attribute">right</span>: <span class="number">0</span></span><br><span class="line">   <span class="attribute">top</span>:<span class="number">0</span></span><br><span class="line">   <span class="attribute">bottom</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="selector-id">#footer</span></span><br><span class="line">     <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;footer_bg&#x27;</span>) != false</span><br><span class="line">       <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">       <span class="attribute">position</span>: absolute</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">       <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">       <span class="attribute">background-color</span>: <span class="built_in">alpha</span>(<span class="variable">$dark</span>-black, .<span class="number">1</span>)</span><br><span class="line">       <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">- <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>固定宽度：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 鱼塘固定宽度 */</span></span><br><span class="line"><span class="selector-tag">canvas</span><span class="selector-pseudo">:not</span>(<span class="selector-id">#ribbon-canvas</span>), <span class="selector-id">#web_bg</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: -<span class="number">0.5rem</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">160px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开启懒加载：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>6.S081</title>
      <link href="/posts/53038.html"/>
      <url>/posts/53038.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux_base</title>
      <link href="/posts/1f6200b9.html"/>
      <url>/posts/1f6200b9.html</url>
      
        <content type="html"><![CDATA[<p>深重悼念，<a href="http://www.cnblogs.com/vamei">Vamei</a></p><p>斯人已逝，文章永存</p><h3 id="Linux架构"><a href="#Linux架构" class="headerlink" title="Linux架构"></a>Linux架构</h3><p>开机时，计算机从主板BIOS(basic input/output system)中读出程序，该程序的作用是使CPU对各个硬件连接识别，然后指向启动计算机的硬件位置，可以选择启动计算机的位置</p><p>之后从选定的位置读取前512个字节，称为主引导记录MBR，MBR再从指定的分区加载引导加载程序(boot loader),引导加载程序加载操作系统内核(kernel)</p><p>内核直接管理硬件，内核之上是系统调用</p><p>内核通过驱动检测硬件以后，创建一个init进程，init运行一系列初始脚本，进行准备工作，对计算机进行一系列的初始化，之后弹出登录框，允许用户以某个组的某个用户登录</p><p>linux架构：</p><p><img src="/posts/1f6200b9.htm/linux_base_01.jpg" alt="Linux架构"></p><p>如图，系统调用是对内和的进一步抽象，系统调用也是操作系统的原子操作，系统调用之上的封装是库函数</p><p>用<code>man 2 syscall</code>可以查看所有系统调用，也可以查看具体的系统调用说明，如<code>man 2 read</code><br>(其中2代表系统调用类，具体的数字和对应的类可以用<code>man man</code>查看)</p><p>shell是一个程序，有内置的函数以及可以运行可执行文件(包括命令)，默认的shell是bash，查看用<code>echo $SHELL</code>，还有其他种类的shell<br>shell也是可编程的，shell脚本<br>shell最大的作用是高效实现各个独立程序之间的协同</p><hr><h3 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h3><p>程序是指令的集合<br>进程是程序的执行过程，为程序执行开辟空间等<br>操作系统管理的是进程</p><p>可以用<code>ps</code>命令查看进程</p><p>linux的进程其实为初始init进程对自己不断调用fork复制的结果<br>所以进程结构为以init进程为树根的树状结构，使用<code>pstree</code>查看</p><p>子进程终结以后，退出信息会存到内核中，父进程会从内核中wait子进程，调出退出信息</p><p>如果父进程没有wait，成为孤儿进程(orphand)，父进程成为init</p><hr><h3 id="Linux信号"><a href="#Linux信号" class="headerlink" title="Linux信号"></a>Linux信号</h3><p>Linux进程之间相互独立，信号是一种进程之间相互传递信息的方式</p><p>信号由内核或者其他进程产生，可以对信号进行执行(deliver)或者阻塞(block)</p><p>内核中对每个进程存储有一个<strong>表</strong>，当传递某个信号，将信号加到表中，进程在执行完系统调用后会查看表，接收信号，可以用<code>man 7 signal</code>查看信号</p><p>signal.signal(signalnum, handler)函数，第一个参数为信号宏(如SIGINT),也可以为数字(具体看<code>man 7 siganl</code>);第二个参数为处理方法(可以自定义对象或者函数)</p><p>如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> signal, time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">signum, time</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI got aSIGINT, but I am notstopping&quot;</span>)</span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time.sleep(<span class="number">.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\r&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>(/r用处是光标回到行首)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bash/bin/env</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">n=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    time.sleep(<span class="number">.3</span>)</span><br><span class="line">    n=n+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>bg运行以后无法中断，是因为中断在while循环里运行，所以只能kill终止或者挂起</p><p>常见信号：<br>Ctrl+C      SIGINT<br>Ctrl+\      SIGQUIT<br>Ctrl+Z      SIGSTOP<br>kill -TERM \<pid>       SIGTERM(终止)</pid></p><p>信号处理(signal disposition)有三种方式：</p><ol><li>默认(default)    SIG_DFT</li><li>忽略(ignore)     SIG_IGN</li><li>自定义处理</li></ol><p>恢复暂停使用<code>fg</code>或<code>bg</code>命令，参数为$!代表上一条命令，也可以使用%n，n为jobs里查看的任务编号</p><p><code>jobs</code>会列出当前终端中未完成的任务，可以使用<code>pgrep</code>查找pid</p><p>后缀加一个&amp;可以让其在后台运行(但输出仍然在终端标准输出)</p><p>nohup可以让程序忽略SIGHUP信号，因为默认shell中运行的程序都是shell的子进程，所以关闭shell以后程序会默认终止，如：<br><code>nohup sleep 2000 &amp;</code></p><h4 id="远端连接-SSH"><a href="#远端连接-SSH" class="headerlink" title="远端连接(SSH)"></a>远端连接(SSH)</h4><p>命令：<br><code>ssh foo@bar.mit.edu</code></p><p>其中foo是用户名，@后是服务器，服务器可以通过URL或者IP指定</p><p>ssh可以直接远程执行命令，如：<br><code>ssh foo@server ls | grep pattern</code>是在本地查询远端ls命令<br>而<code>ls | ssh foo@server grep pattern</code>是在远端对本地ls进行查询</p><p>ssh密钥：</p><p>首先了解一下CA证书：</p><p><strong>CA证书</strong>指的是CA机构为每个合法公钥持有者办法的一个数字签名证书，证书内含有分配的公钥，一个用户将验证另一个用户的真伪，可以用CA公钥对那个证书上的签字进行验证<br>CA将CA为其分配的公钥和申请者的信息绑在一起，并为他形成签字</p><p>其次了解一下对称加密和非对称加密(RSA)</p><p>对称加密是指client端和server端加密解密用的是同一个密钥<br><img src="/posts/1f6200b9.htm/linux_base_02.png" alt="client"><br><img src="/posts/1f6200b9.htm/linux_base_03.png" alt="server"></p><p>server对每个client分配密钥，但是容易泄露</p><p>所以用非对称加密，使用一对公钥和私钥，server端有公钥和私钥，client访问时，server将公钥给client进行加密，密文传给server以后，用私钥进行解密，再进行验证<br><img src="/posts/1f6200b9.htm/linux_base_04.png" alt="RSA"></p><p>但仍有被发送攻击者的公钥的风险(中间人攻击)，所以要根据公钥指纹认证公钥</p><p>有一种免登录的ssh方法：<strong>公钥登录</strong><br>将client的公钥记录到server上，具体过程为登录的时候server生成随机数R，公钥加密，传给client，client私钥解密，比较是否相等</p><p>私钥位置：<code>~/.ssh/id_rsa</code>(慎重保管！)</p><p>生成一对密钥：<br><code>ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</code></p><p>ssh会查询.ssh/authorized_keys来确认哪些用户允许登录<br>拷贝其他server的认证公钥：<br><code>cat .ssh/id_ed25519 | ssh foo@remote &#39;cat &gt;&gt; ~/.ssh/authorized_keys&#39;</code></p><p>ssh复制文件:<br><code>scp path/to/local_file remote_host:path/to/remote_file</code></p><p>监听远程服务器需要<strong>端口转发</strong></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><hr><h4 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h4><p>fork()函数用于创建进程，有两个返回值，在子进程中返回0，在父进程中返回子进程PID<br>fork函数创建子进程的方式为：</p><ol><li>申请PID</li><li>申请PCB</li><li>复制父进程PCB</li><li>初始化子进程</li><li>复制父进程的页(使用写时拷贝，写时拷贝指对只读区域在修改的时候要拷贝一份才可以做修改)</li></ol><p>fork函数执行的时候，一个函数会在其创建的子进程和父进程中各执行以此，但父进程和子进程那个先执行不一定，所以</p><hr><h4 id="堆-OS"><a href="#堆-OS" class="headerlink" title="堆(OS)"></a>堆(OS)</h4><p>操作系统中的堆指的是一段在程序运行的时候申请的内存空间，不同于栈，栈是一级缓存，用来存放函数参数名以及信息等，堆是二级缓存，程序运行结束的时候释放，程序员可以用malloc等函数申请<br>注意堆是在程序开始运行的时候就根据库函数申请了一段内存，OS存储堆的大小和初始地址，free()释放地址，程序员申请堆其实是在已经申请好的堆中获取存储大小，可以加速效率</p><h4 id="format-函数"><a href="#format-函数" class="headerlink" title="format()函数"></a>format()函数</h4><p>用于格式化字符串</p><ol><li><code>print(&quot;&#123;&#125;&#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;))</code></li><li><code>site = &#123;&quot;name&quot;:&quot;1&quot;, &quot;url&quot;:&quot;www.marvoalou.github.io&quot;&#125;</code><br><code>print(&quot;&#123;name&#125;,&#123;url&#125;&quot;.format(**site))</code></li><li><code>list=[&#39;zxy&#39;,&#39;man&#39;]</code><br><code>print(&quot;&#123;0[0]&#125;&#123;0[1]&#125;&quot;.format(list))</code></li><li><code>print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;))</code></li><li><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AssignValue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">    self.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;value 为: &#123;0.value&#125;&#x27;</span>.<span class="built_in">format</span>(my_value))  <span class="comment"># &quot;0&quot; 是可选的</span></span><br></pre></td></tr></table></figure></li><li><p>格式化：具体查询</p></li></ol><h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><p>功能：</p><ol><li><p>它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用</p></li><li><p>它可以让新窗口”接入”已经存在的会话</p></li><li><p>它允许每个会话有多个连接窗口，因此可以多人实时共享会话</p></li><li><p>它还支持窗口任意的垂直和水平拆分</p></li></ol><p>帮助：      <code>Ctrl+b ?</code></p><p>新建会话:       <code>tmux new -s &lt;session-name&gt;</code></p><p>分离会话：      <code>Ctrl+b d</code></p><p>查看所有会话：        <code>tmux ls</code>or<code>Ctrl+b s</code></p><p>接入会话：      <code>tmux attach -t &lt;num&gt;or&lt;session-name&gt;</code></p><p>结束会话：      <code>tmux kill-session -t &lt;name&gt;</code></p><p>切换：      <code>tmux switch -t &lt;name&gt;</code></p><p>重命名：        <code>tmux rename-session -t 0 &lt;new-name&gt;</code></p><p>划分窗格：      <code>tmux split-window &lt;-h&gt;(左右)</code>or<code>Ctrl+b %</code>or<code>Ctrl+b &quot;</code></p><p>移动光标：      <code>tmux select-pane -U/-D/-L/-R</code>or<code>Ctrl+b 方向键</code></p><p>交换位置：      <code>tmux swap-pane -U/-D</code></p><p>其余具体看教程</p><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p><code>alias ll=&quot;ls -lh&quot;</code></p><p>忽略别名：<br><code>\ls</code></p><p>禁用别名：<br><code>unalias ll</code></p><p>获取别名定义：<br><code>alias ll</code></p><p>别名放在.zshrc配置文件里</p><p>配置文件是隐藏文件，也称为点文件</p><p>常见的配置文件;<br><code>bash</code> - <code>~/.bashrc</code><br><code>git</code> - <code>~/.gitconfig</code><br><code>vim</code> - <code>~/.vimrc</code><br><code>ssh</code> - <code>~/.ssh/config</code><br><code>tmux</code> - <code>~/.tmux.conf</code></p><p>配置文件支持shell脚本，所以想要配置文件实现一些具体的功能(如在不同设备使用不同配置)，可以添加shell脚本</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ml</title>
      <link href="/posts/d58e2a66.html"/>
      <url>/posts/d58e2a66.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>2023</code>年<code>11</code>月<code>8</code>日学习<code>ML</code>，共耗时：<code>6</code>小时</strong><br><strong>学习资料：<a href="http://www.ai-start.com/ml2014/html/">machine learning</a></strong></p><blockquote><p>正视自己现在的态度：想做建大的事情并且快速获得可以擦后果别人的成果，想什么呢？<br>只有掌握技术，才能去享受技术，就像只有会游泳才能享受游泳的乐趣，如果中途半途而废了，那么之前做的一切都会没有价值<br>既然选择了走这么一条艰难地路，顶一个宏大的目标，那就坚持下去</p><h2 id="监督学习和无监督学习"><a href="#监督学习和无监督学习" class="headerlink" title="监督学习和无监督学习"></a>监督学习和无监督学习</h2><p>监督学习：回归问题或者对于已知种类的分类判断问题<br>无监督学习：对于未知种类的自动判断种类(聚类算法)    </p></blockquote><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>特征相当于变量，不同问题的特征值是不一样的，机器学习是对于某一种具有相同特征值的问题进行处理的方法<br>梯度下降对于参数求导数，来判断参数往哪个方向调整会产生预期结果</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>最简单的对于一元自变量：<br>多个数据来拟合一条直线，来进行预测或者分类，对于离散问题也可以使用线性回归：    </p><script type="math/tex; mode=display">y = \beta_0 + \beta_1 x_i</script><p>残差：  </p><script type="math/tex; mode=display">e = y - \widehat{y}</script><p>损失函数：残差平方和<br>可以使用最小二乘法来求解拟合直线参数 $\beta_0$ 和 $\beta_1$ :<br>对于残差平方和$Q,\beta_0,\beta_1$，图像是三维凸函数，所以极小值是对$\beta_0.\beta_1$求偏导为0的点   </p><script type="math/tex; mode=display">\frac{\partial Q}{\partial\beta_0} = 2\sum_{1}^n(y_i - \widehat{\beta_0} - \widehat{\beta_1}x_i) = 0</script><script type="math/tex; mode=display">\frac{\partial Q}{\partial\beta_1} = 2\sum_{1}^n(y_i - \widehat{\beta_0} - \widehat{\beta_1}x_i)x_i = 0</script><p>（多维的话就对多个进行偏导求解）<br>可以用来求解局部最小值或者全局最小值<br>拟合的时候不一定使用线性回归，也可能使用其他函数的回归，看对于数据点那个比较适用  </p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>思想是：<br>对于一个预测问题或者分类问题需要去数学建模来构造预测函数，于是建模有函数 $h(\Theta^TX)$ 作为预测假设<br>接下来需要改良假设的拟合效果，所以要通过学习来更新矩阵 $\Theta$<br>评判标准：代价函数 <script type="math/tex">J(\theta_1,\theta_2,\dots,\theta_n)</script> 代表了当前选取的参数的建模误差<br>为了要代价函数最小，所以根据代价函数的值来更新 <script type="math/tex">\theta_i</script><br>于是有对 $J$ 对 $\theta_i$ 求偏导的方法来更新 $\theta_i$ 值  </p><p>批量梯度下降(因为每一步用到了所有的数据点)：<br>选取随机的参数组合 <script type="math/tex">(\theta_0,\theta_1\dots\theta_n)</script>,来对每个参数组合求解局部最小值，来寻找全局最小值  </p><script type="math/tex; mode=display">\theta_j=\theta_j - \alpha \frac{\partial}{\partial \theta_j}J(\theta_0, \theta-1)</script><p>其中 $\alpha$ 称为学习率，也看作步长，$\theta_0和\theta_1会及时更新$</p><p>(为什么要使用梯度下降：不是所有函数都能求偏导，函数也可能是黑盒，并且偏导等于0的点不一定是极值点) </p><h3 id="多维梯度下降"><a href="#多维梯度下降" class="headerlink" title="多维梯度下降"></a>多维梯度下降</h3><p>判断函数： <script type="math/tex">h_\theta(x) = \theta^T X</script><br>梯度下降函数： <script type="math/tex">\theta_j = \theta_j - \alpha\frac{1}{m}\sum_{i=1}^m((h/-\theta(x^{(i)}) - y^{(i)})x_j^{(i)})</script><br>注意多项式不一定是线性的，有可能是高次的，但是参数是线性的，不影响对于参数的梯度下降<br>选取正确的模型方程很重要</p><h3 id="梯度下降优化"><a href="#梯度下降优化" class="headerlink" title="梯度下降优化"></a>梯度下降优化</h3><p>统一特征尺度，为了准确度，需要将特征尺度统一到(0,1)的区间：  </p><script type="math/tex; mode=display">x_n = \frac{x_n - \mu_n}{s_n}</script><p>其中 $\mu_n,s_n$为平均值和标准差</p><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><p>对于<strong>线性回归问题</strong><br>当特征值少的时候，可以直接用正规方程的方法来得到最合适的参数矩阵：  </p><script type="math/tex; mode=display">\theta = (X^TX)^{-1}X^Ty</script><p>直接可以求得最小代价函数的参数矩阵<br>对于小样本数但是需要多个参数的时候，使用正则化来减少特征值个数</p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>线性回归拟合+预测值用sigmod函数来进行分类 </p><p>决策边界：<br>来判断分类种类的函数，所以对于比较复杂的分类种类，通常需要选取复杂的决策边界函数 $\theta^TX$ 才行   </p><p>对于决策边界$w_1 x_1+w_2 x_2 + b = 0$，有决策函数$g(w_1 x_1+w_2 x_2 + b)$<br>即$w_1 x_1+w_2 x_2 + b &gt; 0$为类别$Y = 1$，小于0则是另一类，用来表示$P(Y = 1 \mid x)$<br>其中x表示x向量$(x_1 , x_2)$，用$W^T$表示向量$(w_1, w_2)$,<br>定义对数几率 $\ln{\frac{y}{1-y}} = w_T x + b$ 与x成线性关系，其中y是为1的概率<br>所以逻辑回归要先拟合出决策边界，在将这个边界和分类概率建立联系<br>逻辑回归也需要使用特征缩放  </p><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>对于逻辑回归，假设函数给出的是离散值，所以需要sigmod函数来把连续值的输出离散化：</p><script type="math/tex; mode=display">h_\theta(x) = g(\Theta^TX)</script><script type="math/tex; mode=display">g(z) = \frac{1}{1+e^{-z}}</script><p>如果按原来的方法构建代价函数的话，会产生一个非凸函数，会陷入局部最小值里<br>所以构建误差函数：  </p><script type="math/tex; mode=display">Cost(h_\theta(x),y) = -y \times \ln(h_\theta(x)) - (1-y)\times\ln(1-h_\theta(x))</script><p>然后求和求偏导得到代价函数 $J(\theta)$</p><h3 id="更优化的学习方法"><a href="#更优化的学习方法" class="headerlink" title="更优化的学习方法"></a>更优化的学习方法</h3><p>共轭梯度法 BFGS (变尺度法) 和L-BFGS (限制变尺度法)<br>有智能的内部循环（线性搜索）来自动选取学习率    </p><h3 id="一对多分类"><a href="#一对多分类" class="headerlink" title="一对多分类"></a>一对多分类</h3><p>对于有多个种类的分类方法，计算每一个类别的概率函数<br>将其中一个类看做正向类，其余看做负向类<br>有取 $\max(h_\theta^{(i)}(x))$</p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>为了防止过拟合的问题，使用正则化来扩大某个参数的影响，以减小这个参数的值，做到减小这个参数影响力的效果<br>正则化线性回归的代价函数为：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m}\sum_{i=1}^{m}[((h_\theta(x^i)-y^i)^2 + \lambda\sum_{j=1}^{n}\theta_j^2)]</script><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>当特征变量多了以后，不同次方的组合数太多了，比如对图片的像素特征处理，所以要用到神经网络<br>神经网络通过多层权重(参数)矩阵能进行十分庞大的种类变换，而且变换是传播扩散的，也可以将特征变量通过权重矩阵扩展到多维，来产生任意维的输出<br>g(x)表示sigmod函数</p><p>每一次层的参数矩阵对上一层输出的特征值或者中间值进行处理，来生成下一层的输入</p><p>可以有多个结果的输出值，即为多分类问题，也可以改变偏差单位(bias unit)来进行逻辑运算操作，从左到右的网络称之为向前传播算法，多分类问题的输出变量是一个向量   </p><p>$s<em>l$代表l层，$\theta_l$代表l层到l+1层的参数矩阵，其大小为 $s</em>{l+1} \times s_l + 1$，所以神经网络的代价函数是多余每一个分类的代价函数的和和正则化每一个参数的平方和 </p><h3 id="反向传播梯度优化"><a href="#反向传播梯度优化" class="headerlink" title="反向传播梯度优化"></a>反向传播梯度优化</h3><p>为了计算对于某一层的某一个参数的对于代价函数 $J(\theta)$的偏导数，需要用到反向传播的方法来求<br>首先由正向传播计算得到神经网络的预测值，然后从后往前有：</p><script type="math/tex; mode=display">\sigma^{(l)} = (\Theta^{(l)})^T\sigma^{(l+1)}*g'(z^{(l)})</script><script type="math/tex; mode=display">\frac{\partial}{\partial\Theta_{ij}^{(l)}} J(Ttheta) = \alpha_j^{(l)}\sigma_i^{(l+1)}</script><p>表示第l层的第j个激活单元收到了第l层的第i行参数的影响而产生的误差单元<br>如果特征值是一个特征矩阵，那么会产生一个误差矩阵 $\triangle_{ij}^l$</p><h3 id="神经网络的训练步骤"><a href="#神经网络的训练步骤" class="headerlink" title="神经网络的训练步骤"></a>神经网络的训练步骤</h3><ul><li>参数随机初始化</li><li>正向传播计算 $h_\theta(x)$</li><li>计算代价函数</li><li>反向传播计算偏导</li><li>数值检验校验偏导</li><li>优化算法最小化代价函数</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>基本的减小误差的思路：</p><ul><li>使用更多样本</li><li>减少特征数量</li><li>增加特征数量</li><li>增加多项式复杂度</li><li>减少正则化程度</li><li>增加正则化程度</li></ul><p>区部分数据集作为训练集、部分数据集作为测试集</p><p>进一步，可以使用交叉验证(cross validation error)来选取一部分数据作为交叉验证集，不同的数据集组合会对同一个模型产生不同的学习器(注意区分概念)，交叉验证集用于对不同学习器进行拟合度校验，有不同的算法和参数确定不同的模型，再在每个模型中通过交叉验证得到不同的学习器，对于k折交叉验证得到的学习器拟和的准确率取平均作为打分，来找到最佳的模型</p><p>数据拟合不好无非两种情况：过拟合和欠拟合</p><p>使用交叉验证时，随着多项式次数的增长，会由欠拟合到过拟合，错误率是下凸函数，所以要判断是偏差/欠拟合还是方差/过拟合</p><p>训练集误差和交叉验证集误差近似时：偏差/欠拟合 交叉验证集误差远大于训练集误差时：方差/过拟合</p><p>对于正则化参数的选择 $\lambda$ 也是，通常是使用 0-10之间的呈现2倍关系的值</p><p>训练集误差随着 $lambda$ 值的增大而增大，交叉验证集误差随着 $\lambda$值的增大而先增大后减小，由过拟合到欠拟合</p><h3 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h3><p>当训练较少行数据的时候，训练的模型将能够非常完美地适应较少的训练数据，但是训练出来的模型却不能很好地适应交叉验证集数据或测试集数据</p><p>将训练集误差和交叉测试集误差作为训练样本规模的函数</p><p>区分欠拟合/过拟合：<br>对于欠拟合，增加训练集规模的时候训练误差和交叉测试集误差趋于稳定，不受影响<br>当过拟合的时候，交叉测试集误差明显大于训练集误差，增加训练集规模效果显著    </p><h3 id="误差检验"><a href="#误差检验" class="headerlink" title="误差检验"></a>误差检验</h3><p>思想：不要想着一开始就得到完美的模型，是需要用方法来验证以及用证据来指导进一步的优化和方向的，有时候不能仅凭直觉来解决问题  </p><ul><li>简单算法，使用交叉验证集测试</li><li>绘制学习曲线来决定进一步的选择</li><li>误差检验，来看是否有什么系统化的趋势</li></ul><h3 id="数值误差度量"><a href="#数值误差度量" class="headerlink" title="数值误差度量"></a>数值误差度量</h3><p>查准率(P)：判断正例中的真正例的比例<br>查全率(R)：真正例中判断出的比例<br>有TP\FN\FP\TN</p><script type="math/tex; mode=display">P = \frac{TP}{TP+FP}</script><script type="math/tex; mode=display">R = \frac{TP}{TP+FN}</script><p>一般两者矛盾，所以使用F1方法度量：  </p><script type="math/tex; mode=display">\frac{1}{F_1} = \frac{1}{2}(\frac{1}{P} + \frac{1}{R})</script><p>加权调和平均：  $F_\beta$</p><script type="math/tex; mode=display">\frac{1}{F_\beta} = \frac{1}{1+\beta^2}(\frac{1}{P} + \frac{\beta^2}{R})</script><ul><li>$\beta = 1$即为 $F_1$</li><li>$\beta &lt; 1$查准更多</li><li>$\beta &gt; 1$查全更多</li></ul><h3 id="数据的地位"><a href="#数据的地位" class="headerlink" title="数据的地位"></a>数据的地位</h3><blockquote><p>取得成功的人不是拥有最好算法的人，而是拥有最多数据的人</p></blockquote><p>所谓好的算法是数据集不足的时候也能给出低方差低偏差的预测结果</p><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>math</title>
      <link href="/posts/a927044d.html"/>
      <url>/posts/a927044d.html</url>
      
        <content type="html"><![CDATA[<p>现在总有一种恍惚感和不安感，觉得自己的付出的时间没有产出，对未来很没有底气和把握，总觉得目前的学习状态不是一个优秀的人该有的状态</p><p>不得不说我一直忽略了一个东西:”数学”<br>太过注重所谓的技术了，结果是编程语言也用不好，只能对于框架开始自娱自乐了</p><p>有这么一句话：<br>一流程序员看数学<br>二流程序员看算法<br>三流程序员看逻辑<br>四流程序员看框架<br>五流程序员看Google</p><p>对于一个本科是计算机专业的人来讲，计算机也许只是跳板罢了，是一个可以让我走向很多岗位的跳板，我现在太把那些看起来堂而皇之的技术名词以及在既定框架下做着重复性工作的计算机技术看重了，对于一个重复性工作，是个人一直做上两年都可以做的滚瓜烂熟，没有任何门槛，只是工具的使用，所以没有任何价值，永远也可以被取代</p><p>然而我现在连这些简单的事情都做不好</p><p>代码只是工具罢了，只是让我们实现一个什么东西的工具，就像公式是让我们能把题解出来的公式，对于这些东西要<strong>理解本质，理解它是个什么东西，我们什么时候可以用到它</strong>，那就很好掌握，可以很快很简单</p><p>数学才是决定上限的，需要是造轮子的能力，需要的是可以有自己的新点子，创造性地想法，在这一领域实现”创造”，而不是复刻，才有价值，要实现创造需要完全理解</p><p>不要急躁，计算机的特点是达到理解的周期长，不像是高中数学和物理一样看一眼公式就可以理解了</p><p>所以需要，静下心来深刻理解每一个小的东西是干什么，比如遇到Django，要深刻理解这个函数是创建了一个什么，创建了这个东西可以干什么</p><p>切忌快速吸收和掌握的浮躁，那样会只限于表面，只限于它教你的知识，而不具备任何创造的能力</p><p><strong>根除沽名钓誉之心，摒弃急功近利之意，涤荡冒进浮躁之气</strong><br>未来能不能找到工作，未来要保研还是考研，这不是我一个低年级大学生应该考虑的问题，不要功利心太重了，也不要野心太大了，享受当下，向着热爱进发就好了</p><p>最大的问题出现在心态上</p><p>我初中之所以学得好，是因为不被“目标”所拘束住，只是关注于学习本身，用摆烂的心态去学习(渡过冷启动时期)真的是一种美德</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>database</title>
      <link href="/posts/c953062e.html"/>
      <url>/posts/c953062e.html</url>
      
        <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/OceanBase-Partner/lectures-on-dbms-implementation/blob/main/lecture-2.md">miniob_lecture</a><br><a href="https://zhuanlan.zhihu.com/p/149287061">知乎-B+树看这一篇就够了</a><br><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p><h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><p>存储大小：盘面——磁道——扇区<br>延时：寻道时间——旋转延迟——数据传输时间  </p><ul><li>增加奇偶位来判断数据是否正确</li></ul><p>数据要进行字节对齐<br>记录和块都有一个header来对时间戳或者偏移量来进行存储，便于数据的查找和维护，数据块对记录的存储是朝向header的栈<br>变长记录的存储：    </p><ul><li>变长字段：首地址(address) + 字段长度  （注意变长字段一般在定长字段之后存储）</li><li>重复字段：首地址 + 字段长度 + 重复次数    </li></ul><p>文件使用堆文件，<strong>记录</strong>能插则插，为了保证页面一致性所以通常一个堆文件是一种关系</p><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>主流操作系统对文件的处理是将文件视为无结构的流文件，只关心数据的传输而不关心数据的格式，而DBMS将流文件划分为页(虚拟分页)来进行内存和磁盘数据的交换<br>文件分页，同一关系的文件放到一个页里<br>DBMS有一个间接层，将页面ID映射成文件路径和偏移量，单文件只映射成偏移量<br>数据库页是硬件页的整数倍(所以DBMS要保证一致性问题)，是缓冲和磁盘交换的基本单位<br>页头存储页面元数据，有些数据库要求页头自包含，数据区对每个记录的存储方式是采用插槽</p><h4 id="记录存储"><a href="#记录存储" class="headerlink" title="记录存储"></a>记录存储</h4><p>记录以插槽方式存储，插槽个数维护在页头中，维护：</p><ul><li>最后一个使用的插槽的起始位置</li><li>插槽数组数</li><li>已使用的槽的数量<br>插槽个数是变化的，记录插入也是变化的，所以槽数组(指的是页头)从前向后增长，而被插入的记录数据则是从页尾向前增长，顶到就是满了(啊哈~)</li></ul><p>记录组织结构，对于变长记录有两种：</p><ul><li>记录头存储第一个变长字段的起始位置，以及除第一个以外所有变长字段的偏移量</li><li>字段定长，维护一个溢出表，字段指针指向，当存储大数据的时候也要用溢出表(但是会增加IO)</li></ul><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>DBMS为了实现数据的永久存储，面向的是磁盘，但是要以内存作为数据交换的媒介，所以将内存作为缓冲区，将数据以页为单位从磁盘提到内存中，这个过程由缓冲区管理器实现<br>缓冲池是内存用于缓冲页的空间，缓冲池管理器是给内存分配缓冲空间的子系统  </p><p>内存会维护一个页表，用于记录页面的磁盘映射和顺序关系，同时也维护了两种：    </p><ul><li>脏标志：表示有线程更新了磁内存中的页，需要从内存取出来更新磁盘</li><li>引用计数器：表示引用内存中的页的数量，大于0则不允许取出内存，相当于加锁</li></ul><p>这个缓冲池和操作系统的缓冲区很像，但是在内存中是分开的，会对OS的缓冲IO进行绕过来加速和简化DBMS对数据的访问处理  </p><p>缓冲区的页面<strong>替换算法</strong>：  </p><ul><li>LRU-K：记录几次历史的最近使用时间(时间戳放在页表)，以及时间间隔，来预测使用可能   (感觉很多os问题的解决方法就是空间换时间，没有什么很巧妙的方法)</li><li>淘汰局部化：对每个查询进行局部页面淘汰</li><li>优先级：根据页面上下文来判断其重要性</li></ul><p>对脏页的写回(后台写)：<br>DBMS定期扫描页表，发现脏页进行安全写回(保证没在被使用)，然后取消脏标志<br><strong>淘汰页面时对脏页的处理可能是一个很重要的优化点</strong>  </p><p>缓冲池优化：<br>多缓冲池：  </p><ul><li>每个数据库一个缓冲池</li><li>不同缓冲池量身定制不同的策略</li><li>对象ID，需要扩展元数据，使其包含关于每个缓冲池正在管理哪些数据库对象的信息，然后通过对象ID，就可以实现从对象到特定缓冲池的映射</li><li>散列，DBMS散列页面ID以选择访问哪个缓冲池<br>预取：<br>在处理第一组页面时，系统可以将第二组页面预取到缓冲池中</li></ul><h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B+ tree"></a>B+ tree</h2><p>一颗，简单的，多路平衡树，但是代表了树的精华<br>B+ tree中的数据指针都存储在叶子结点上，指针指向的是磁盘区域，数据均以键值对形式存储，便于高效查找和维护，查找磁盘中的内容是按照键值key来进行查找的<br>B+ tree的阶：代表了每个内部节点能拥有的最大子节点个数m，能容纳的最大数据为m-1，阶太大的话会提高删除和增加节点的复杂性，阶太小的话会增加输的高度<br>B+ tree的结点数据个数最小不能小于[m/2]<br>内部节点存储的是用于查询的关键字，不一定要存储所有<br>这里的B+ tree根节点包含最大值</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>几种情况：</p><ul><li>叶节点数据值指针个数小于阶数，直接插入</li><li>叶节点数据值指针个数等于阶数，父节点数据指针个数小于阶数，分裂后插入，并将[m/2]的叶节点提到父节点作为索引</li><li>叶节点数据值指针个数等于阶数，父节点数据指针个数等于阶数，叶节点分裂一次，父节点再分裂一次，不断向上直到有未满阶的内部节点    </li><li>插入值大于最大值，则根节点和内部节点替换目前的最大值，然后正常插入分裂等</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>删除以后所在的叶子结点数据个数大于[m/2]，直接删除</li><li>删除最大最小值，直接全部替换次大次小值</li><li>删除以后所在的叶子结点数据个数小于[m/2]，像兄弟节点借一个，然后改变一下父节点</li><li>如果兄弟节点没有多余的关键字可以借，那删除之后合并，并回溯更改所有内部节点关键字</li><li>如果回溯的时候存在不满足B+ tree要求的情况，依照以上步骤进行处理</li></ul><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>$\log_m (N)$</p><h2 id="SQL引擎结构"><a href="#SQL引擎结构" class="headerlink" title="SQL引擎结构"></a>SQL引擎结构</h2><p>parser : 将sql语句翻译成语法树<br>resolver : 对parser语法树进行进一步的约束检查和属性提取(会翻译成另一种数据结构)<br><a href="https://www.modb.pro/db/1701966184379928576">parser和resolver</a><br>transformer&amp;optimizor : 基于代价和基于改写的查询优化    </p><p>关系运算：常使用的有笛卡尔积和自然连接，查询的本质就是对集合关系的数学表达，查询优化要找到计算代价最小的集合关系计算方法    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-01</title>
      <link href="/posts/7b347bb3.html"/>
      <url>/posts/7b347bb3.html</url>
      
        <content type="html"><![CDATA[<p>进程是程序执行，以及内存空间，以及执行上下文等一系列要素</p><p>线程是一个进程中的多个小的执行单元，其共享进程的堆和方法栈的资源，可以并发，每个线程有自己的程序计数器</p><p>线程崩溃则整个进程崩溃，因为线程不是独立的，但是各个进程之间是完全独立的，所以多进程比多线程健壮</p><p>线程切换只是CPU的直接访问切换，但是进程切换是包括分配内存空间，保存和产生执行上下文等步骤的切换，所以线程切换比进程开销更小</p><p><strong>虚存：</strong>通过进程的分页设计，来让进程的一部分在运行进程的时候可以从外存实时加载到内存，以减少内存的开销</p><h3 id="虚存"><a href="#虚存" class="headerlink" title="虚存"></a>虚存</h3><p>先介绍几个定义：</p><ol><li>段：有代码段和数据段，每个段在内存中占用连续的物理空间</li><li>CS寄存器：存储代码段的段基址，或者存放段选择子</li><li>DS寄存器：存储数据段的段基址，或者存放段选择子</li><li>IP寄存器：存储代码段的段偏移量</li><li>全局段描述符表：存储在内存中，有各个(可执行文件)代码和数据段的基址</li><li>全局段描述符表寄存器：存储全局段描述符表在内存中的基址</li></ol><p>CPU访问内存中代码段和数据段的方式有以下几种：</p><h4 id="直接存取"><a href="#直接存取" class="headerlink" title="直接存取"></a>直接存取</h4><p>要执行可执行文件时，代码段和数据段被分配唯一的物理地址，但缺点在不能同时执行多次这个程序，而且地址锁定也不灵活</p><h4 id="段基址-段偏移量"><a href="#段基址-段偏移量" class="headerlink" title="段基址+段偏移量"></a>段基址+段偏移量</h4><p>为了灵活访问内存中的不同地方的代码，出现了段基址+段偏移量的方法，典型的是Intel的8086，如图：</p><p>CS寄存器，DS寄存器存放代码段和数据段的段基址，IP寄存器存放段偏移量，访问的时候CPU获取段基址和段偏移量(CS:IP方法)来进行定位</p><p>后续要获取有关段地址的信息时，可以直接从段寄存器里面获取，加快效率</p><h4 id="段选择子-段偏移量"><a href="#段选择子-段偏移量" class="headerlink" title="段选择子+段偏移量"></a>段选择子+段偏移量</h4><p>设置了全局段描述符表，来存放各个段的信息(包括位置基址)<br>段选择子是对某个特定段用于定位其在全局段描述符表中的位置，所以定位方式为：<br>先将段选择自防砸段寄存器中(如S寄存器)，CPU再从段寄存器中获取段选择子的13位高位来确定在全局段描述符表中的位置，再从全局段描述符表寄存器中获取全局段描述符表的基址，计算得段的实际地址，在加上IP寄存器中的偏移量，进行访问</p><h4 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h4><p>虚拟地址是一个进程在执行的时候所分配给的逻辑地址，它并不是在物理地址(内存)，而是一个进程所需要空间的虚拟编号，其实际对应的部分可能在物理内存中，也可能在磁盘中</p><p>为了充分利用物理内存，采用分页系统，将物理内存以4K为一个单位分成若干页，并且每一页编有物理页号，对应的，虚拟内存也以相同大小编成了若干虚拟页，有：<br>物理内存 = 物理页号(PPN) + 物理页偏移量(PPO)<br>虚拟内存 = 虚拟页号(VPN) + 虚拟页偏移量(VPO)</p><p>虚拟页相当于一张为了进程而设计的执行表，是针对进程全面的，要执行进程的时候，需要为了进程而访问的哪一块存储的的时候，找找虚拟页，如果已经要访问的存储在内存中那就再好不过了，如果不在的话，那要不就是在磁盘中，我们就把他放到内存里，要不就是压根没分配存储空间，那我们就给它在磁盘上分配一个再放到内存里</p><p>虚拟页和物理页有一定的映射关系，其映射方法通过硬件MMU实现，虚拟页三种映射状态如下：</p><ol><li>未分配，指虚拟页没有分配磁盘空间</li><li>未缓冲：指虚拟页没有分配到物理内存，而是在映射在磁盘的状态</li><li>已缓冲：指虚拟页已经有了物理内存的映射</li></ol><p>有几个虚拟页的映射是所有进程一致的：<br><strong>内核</strong>和<strong>共享库</strong></p><p>为了判断和管理虚拟页的映射状态，在内存中会有一个<strong>页表(PT)</strong><br>页表有两列：有效位和地址，有效位的0和1和地址列是否为null可以组合判断虚拟页是三种状态的哪一个</p><p>页表专门有一个页表基址寄存器(PTBR)</p><p>以下介绍虚拟地址翻译物理地址的方法：</p><p>有两种结果，命中或者未命中，命中就是虚拟页已缓冲，未命中就是未缓冲或者未分配</p><p>命中：</p><ol><li><p>CPU将虚拟地址(VA)送入MMU,MMU根据页表基址寄存器中页表的起始地址加上虚拟页号，找到了页表项的物理地址PTEA。</p></li><li><p>MMU将PTEA送入到高速缓冲或者内存。</p></li><li><p>从高速缓冲或者内存中找到页表项(PTE)，返回页表项(PTE)给MMU。</p></li><li><p>MMU根据PTE找出物理页号，然后加上虚拟页偏移量形成物理地址(PA),送入到高速缓冲或者内存。</p></li><li><p>高速缓冲或者内存获取数据，返回数据给处理器。</p></li></ol><p>未命中:</p><ol><li><p>CPU将虚拟地址(VA)送入MMU,MMU根据页表基址寄存器中页表的起始地址加上虚拟页号，找到了页表项的物理地址PTEA。</p></li><li><p>MMU将PTEA送入到高速缓冲或者内存。</p></li><li><p>从高速缓冲或者内存中找到页表项(PTE)，返回页表项(PTE)给MMU。</p></li><li><p>MMU根据PTE,发现页不在内存中，未命中，因此MMU发送一个缺页中断，交由缺页异常处理程序处理。</p></li><li><p>缺页异常处理程序根据页置换算法，选择出一个牺牲页，如果这个页面已经被修改了，则写出到磁盘上，最后将这个牺牲页的页表项有效位设置为0，存入磁盘地址。</p></li><li><p>缺页异常程序处理程序调入新的页面，如果该虚拟页尚未分配磁盘空间，则分配磁盘空间，然后磁盘空间的页数据拷贝到空闲的物理页上，并更新PTE的有效位为1，更新物理页号，缺页异常处理程序返回后，再回到发生缺页中断的指令处，重新按照页表项命中的步骤执行</p></li></ol><p>以下介绍虚拟地址翻译物理地址的方法：</p><p>有两种结果，命中或者未命中，命中就是虚拟页已缓冲，未命中就是未缓冲或者未分配</p><p>命中：</p><ol><li><p>CPU将虚拟地址(VA)送入MMU,MMU根据页表基址寄存器中页表的起始地址加上虚拟页号，找到了页表项的物理地址PTEA。</p></li><li><p>MMU将PTEA送入到高速缓冲或者内存。</p></li><li><p>从高速缓冲或者内存中找到页表项(PTE)，返回页表项(PTE)给MMU。</p></li><li><p>MMU根据PTE找出物理页号，然后加上虚拟页偏移量形成物理地址(PA),送入到高速缓冲或者内存。</p></li><li><p>高速缓冲或者内存获取数据，返回数据给处理器。</p></li></ol><p>未命中:</p><ol><li><p>CPU将虚拟地址(VA)送入MMU,MMU根据页表基址寄存器中页表的起始地址加上虚拟页号，找到了页表项的物理地址PTEA。</p></li><li><p>MMU将PTEA送入到高速缓冲或者内存。</p></li><li><p>从高速缓冲或者内存中找到页表项(PTE)，返回页表项(PTE)给MMU。</p></li><li><p>MMU根据PTE,发现页不在内存中，未命中，因此MMU发送一个缺页中断，交由缺页异常处理程序处理。</p></li><li><p>缺页异常处理程序根据页置换算法，选择出一个牺牲页，如果这个页面已经被修改了，则写出到磁盘上，最后将这个牺牲页的页表项有效位设置为0，存入磁盘地址。</p></li><li><p>缺页异常程序处理程序调入新的页面，如果该虚拟页尚未分配磁盘空间，则分配磁盘空间，然后磁盘空间的页数据拷贝到空闲的物理页上，并更新PTE的有效位为1，更新物理页号，缺页异常处理程序返回后，再回到发生缺页中断的指令处，重新按照页表项命中的步骤执行</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-02</title>
      <link href="/posts/e23d2a09.html"/>
      <url>/posts/e23d2a09.html</url>
      
        <content type="html"><![CDATA[<p>进程控制块：操作系统创建和管理，包含了进程的充分信息，可以方便于中断，因为保存了进程的寄存器以及上下文信息等</p><p>进程轨迹：进程执行的指令序列<br>进程轨迹的的交替方式可以描述处理器的行为<br>分派器(调度器)控制进程的切换</p><p>进程创建，可以由进程创建进程，一个进程的显示请求创建了另一个进程的时候，称为进程派生</p><p>两状态模型：运行态和非运行态，有一个进程队列</p><p>五状态模型：非运行态分为了阻塞态和就绪态，还有未加载到内存的新建态以及可以释放的退出态<br>具体看书上的图<br>阻塞——就绪：当等待的事件发生了以后，阻塞态的进程就成为了就绪态<br>运行——就绪：超时<br>运行——阻塞：等待事件</p><p>有阻塞队列和就绪队列，当一个事件发生时，扫描等待这个事件的阻塞队列，把阻塞进程放到就绪队列里</p><p>产生了新的问题：<br>由于处理器速度远大于IO操作的速度，所以可能会存在所有进程都处于IO的情况，内存已满进不来新的进程，解决方法是将阻塞的进程转移到磁盘的<strong>挂起队列(suspend queue)</strong>中，这个行为称之为<strong>交换</strong>，交换也是IO操作，但由于磁盘IO速度是最快的IO，所以往往可以提高效率</p><p>所以阻塞态多了一个交互的状态，成为<strong>挂起态</strong>，当事件发生的时候挂起态进程可以回到内存中运行<br>所以又多了两个状态：阻塞/挂起态和就绪/挂起态<br>成了七状态模型</p><p>资源：文件系统，IO，处理器，内存外存等<br>操作系统可以看做是管理资源的实体，所以需要知道进程和资源的当前状态，所以OS维护4类信息表：内存，I/O，文件和进程</p><p>进程映像包括：数据，程序，栈，进程控制块(属性集)，进程映像可以一部分在内存，一部分在外存，但是执行的时候要可以放到内存中，进程映像也是不连续分页的，操作系统的进程表要知道进程映像每页的位置<br>进程控制块包含的信息：</p><ul><li>进程标识信息(包含标识符等)</li><li>进程状态信息(处理器状态信息)</li><li>进程控制信息</li></ul><p>处理器设置有一个称为程序状态字(PSW)的寄存器，如Intel x86的EFLAGS寄存器，保存程序的大量状态信息</p><p>有个东西叫进程控制块，包含操作系统需要的一个进程的所有信息，为了安全由一个处理程序例程来作为修改进程控制块的仲裁程序</p><p>处理器有两种执行模式：<br>与操作系统相关联的内核模式<br>与用户相关联的用户模式</p><p>内核(操作系统的一部分，管理者重要的系统功能，具体看书)模式的是特权模式，可以访问信息，用户模式权限受限<br>处理器在执行时候区分两种模式的方法是通过PSW的前几位来判断权限</p><p>操作系统进程创建：</p><ol><li>分配一个唯一的进程标识符</li><li>为进程分配空间</li><li>初始化进程控制块：除非继承父进程或者显式请求否则初始时不用有任何资源，优先级默认最低等</li><li>设置链接：进调度队列</li><li>创建其他数据结构：如记账文件等</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/posts/4d712855.html"/>
      <url>/posts/4d712855.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>2022</code>年<code>3</code>月<code>27</code>日学习<code>SQL</code>，共耗时：<code>4</code>小时</strong><br><strong>学习资料：<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611432985088">SQL教程</a></strong></p><p>姑且粗浅了解一下SQL，之后要用或者有时间再细学</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>字段：</strong>数据项，对应为数据库里的列</p><p><strong>记录：</strong>一条由一系列字段组合成的数据，对应为数据库里的行</p><p><strong>主键：</strong>用于对一条记录的唯一字段标识，一般用<code>id</code>或<code>GUID类型</code></p><p><strong>联合主键：</strong>多条字段设置为主键（不常用）</p><p><strong>外键：</strong>用于关联另一个表，使用外键约束会降低数据库的性能，外键约束构造：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_class_id;</span><br></pre></td></tr></table></figure><p><strong>索引：</strong>索引用于快速检索记录，主键是最典型的索引，也可以设置多个索引提高查询效率，索引字段多用hash算法来构造，所以散列值越多，冲突越少，查询效率越高<br>创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>索引的优点是提高了<strong>查询效率</strong>，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>创建唯一索引（不可重复）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>添加唯一约束但是不创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);</span><br></pre></td></tr></table></figure><ol><li>找参数，判断字符型还是数字型</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">sql</span><span class="operator">=</span>&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;</span><br><span class="line">$<span class="keyword">sql</span><span class="operator">=</span>&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;  # 数字</span><br></pre></td></tr></table></figure><ol><li>判断字段数<code>order by 4</code></li><li>判断回显点<code>union select 1,2,3</code></li><li>判断数据库名<code>union select 1,2,database()</code>，表名<code>union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;库名&#39;(或者最后加limit语句来获取指定的表)</code>，列名<code>union select 1,2,group(column_name) from information_schema.columns where table_name=&#39;表名&#39;</code></li><li>显示列内容<code>union select 1,2,group_concat(列名) from 表名</code></li></ol><p>网页SQL语句其实是php代码中的SQL，所以会有类似$id等参数引用来通过get获取</p><p>url中添加注释：<br>—+ 或者 —%20 或者 %23 ，不能用#</p><p>limit语句<br>group_concat()显示所有的内容，但是可能会受到现实的字数限制</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61A-note</title>
      <link href="/posts/83c24a0e.html"/>
      <url>/posts/83c24a0e.html</url>
      
        <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>本质是更上一级的抽象<br>函数可以作为函数的参数,不能作为控制结构的<br>关键在于抽象出概念<br>函数所在的帧是直接父级  </p><p>eg1:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x + y)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, close, guess=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line">        guess = update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x, a/x)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sqrt_close</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(x * x, a)</span><br><span class="line">    <span class="keyword">return</span> improve(sqrt_update, sqrt_close)</span><br><span class="line"></span><br><span class="line">result = sqrt(<span class="number">256</span>)</span><br></pre></td></tr></table></figure><p>函数设计是一种思想，对问题从顶层到底层一步步抽象，，数学中将特殊问题一般化，而模板就是面向一般化的“步骤本身”</p><p>为了能使用抽象模板，一个技巧是以函数为参数可以得到需求形式的函数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> f(g(x))</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_one_and_square = compose1(square, successor)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_one_and_square(<span class="number">12</span>)</span><br><span class="line"><span class="number">169</span></span><br></pre></td></tr></table></figure></p><h3 id="lamda"><a href="#lamda" class="headerlink" title="lamda"></a>lamda</h3><p>也可以使用lamda</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f,g</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>compose1 = <span class="keyword">lambda</span> f,g: <span class="keyword">lambda</span> x: f(g(x))</span><br></pre></td></tr></table></figure></p><p>lamda：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">lambda</span>            x            :          f(g(x))</span><br><span class="line"><span class="string">&quot;A function that    takes x    and returns     f(g(x))&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>思想：等到给参数的时候才进行进一步调用，所以要用到高阶</p><p>用法：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">trace1</span>(<span class="params">fn</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapped</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-&gt; &#x27;</span>, fn, <span class="string">&#x27;(&#x27;</span>, x, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> fn(x)</span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@trace1</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">12</span>)</span><br><span class="line">-&gt;  &lt;function triple at <span class="number">0x102a39848</span>&gt; ( <span class="number">12</span> )</span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure></p><p>本质：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = trace1(triple)</span><br></pre></td></tr></table></figure></p><p>装饰器接受一个函数为参数，返回的本质上也是这个函数</p><p>使用装饰函数，以目标函数作为参数，进行指定的<strong>处理</strong>(装饰)</p><p>可以多重装饰，只要返回值是原函数，装饰只是增加副作用<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">f</span>):           <span class="comment">#这种格式的，经过count和memo的修饰，就会有父帧的call_count属性，以及一些和属性相关的功能，反正不修改函数本身</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">counted</span>(<span class="params">n</span>):</span><br><span class="line">            counted.call_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> f(n)</span><br><span class="line">        counted.call_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> counted</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">memo</span>(<span class="params">f</span>):</span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">memorized</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">                cache[n] = f(n)</span><br><span class="line">            <span class="keyword">return</span> cache[n]</span><br><span class="line">        <span class="keyword">return</span> memorized</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counted_fib = count(fib)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib =memo(count_fib)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">19</span>)</span><br><span class="line"><span class="number">4181</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counted_fib.call_count</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">34</span>)</span><br><span class="line"><span class="number">5702887</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counted_fib.call_count</span><br><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure></p><p>函数式编程思想：<br>所谓函数就是接受对象作为参数，并返回对象的一个盒子，这样看来函数就是一种自己定义的数学运算符，即像是自己定义了一种新的计算，也像是一个数学公式<br>对象可以是类、基本数据、函数，而且函数本身也可以作为对象，这就意味着最小操作类型可以看作是对象，而所谓的类、函数等也不过是一种新的数据类型组织方式<br>所以编写程序的过程就是自己构造一个数学公式来产生目标输出的功能<br>所以关键是，要知道要接受一个怎么样的对象，返回一个什么样功能的对象  </p><p>再例如Web中：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PlatformAuthenticated</span>(<span class="params">auth_level</span>):      <span class="comment">#将验证handler的函数作为修饰器，通过类设置一些外部属性，调用get方法时自动调用call，自动验证</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StrictPlatformAuth</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, handler</span>):</span><br><span class="line">            self.handler = handler</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, request, response</span>):</span><br><span class="line">            auth = request.authorization(auth_level)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;BlahBlahBlah&quot;</span>)</span><br><span class="line">            self.handler(request, response)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StrictPlatformAuth</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebHandler</span>:</span><br><span class="line"><span class="meta">    @PlatformAuthenticated(<span class="params">ADMIN</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, response</span>):</span><br><span class="line">        do_something()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RobotWebHandler</span>:</span><br><span class="line"><span class="meta">    @PlatformAuthenticated(<span class="params">ROBOT</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, response</span>):</span><br><span class="line">        do_something()</span><br></pre></td></tr></table></figure></p><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>多参数函数和指定参数函数之间的转换：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">curry2</span>(<span class="params">f</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回给定的双参数函数的柯里化版本&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">                <span class="keyword">return</span> f(x, y)</span><br><span class="line">            <span class="keyword">return</span> h</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">uncurry2</span>(<span class="params">g</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回给定的柯里化函数的双参数版本&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">            <span class="keyword">return</span> g(x)(y)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow_curried = curry2(<span class="built_in">pow</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow_curried(<span class="number">2</span>)(<span class="number">5</span>)</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_to_range(<span class="number">0</span>, <span class="number">10</span>, pow_curried(<span class="number">2</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">512</span></span><br></pre></td></tr></table></figure></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归思路：自顶向下，只关心下一层，不关心全部(return)<br>只有最后一层才有细节(if n==1)</p><p>要清楚<strong>迭代对象</strong>和<strong>迭代关系</strong><br>以函数为整体看待<br>对应数学归纳法，归纳的时候考虑的是过程中的一般情况以及临界条件，不应该自动带入考虑程序怎么跑<br>只要是序列间有关系的问题都可以用递归解决</p><p>hw03的count_change</p><p>hw04的balance,归纳法：假设这个函数已经成立，可以用这个函数本身来递推的实现功能，再验证边界成立<br>    preorder: 列表本身可以被迭代，所以可以写二重循环</p><h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>序列解构：将序列元素的子序列元素映射到指定的name上</p><p>range是序列</p><p>有.count和.index行为<br>count行为匹配的是非重叠的字符串</p><p>字符串本质也是一种序列，换行符也会被认为是字符串元素<br>字符串的in匹配的是字符串</p><p>接口：使用map，reduce，filter来实现对数据的一系列组件操作，<br>也可以使用生成器表达式：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">acronym</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(w[<span class="number">0</span>] <span class="keyword">for</span> w <span class="keyword">in</span> name.split() <span class="keyword">if</span> iscap(w))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_even_fibs</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(fib(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>) <span class="keyword">if</span> fib(k) % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>使用构造器和选择器对抽象数据进行操作</p><h2 id="2-4-可变数据"><a href="#2-4-可变数据" class="headerlink" title="2.4 可变数据"></a>2.4 可变数据</h2><p>对象是一种数据类型，其中包含函数(操作数据的行为)以及数据，不仅是值，也是一个过程<br><strong>python万物皆对象</strong></p><h4 id="为什么要设计类？"><a href="#为什么要设计类？" class="headerlink" title="为什么要设计类？"></a>为什么要设计类？</h4><p>将数据和行为为基本元素抽象成一个新的数据类型，这种数据类型更加真实地映射了现实世界的对象，从功能上看更便于实现过程和行为的构建，从结构上看提供了强大的数据和行为之间的交互和传递能力(继承，多态)，以及极大地方便了对数据的处理和对行为的调用</p><h3 id="理解抽象"><a href="#理解抽象" class="headerlink" title="理解抽象"></a>理解抽象</h3><p>抽象的最终目的是产生更加通用的模板来简化操作，更通用、更简单地实现更多的任务<br>抽象必然是一层一层的，从计算机硬件电路到硬件模块的封装，从硬件到终端的交互，从基本数据类型到复合数据类型(OOP)，从符合数据类型到一系列数据和行为构成的集合体(包和库)，再到软件的实现<br>实现功能的抽象模块之间应该是尽量独立的，不互相影响的，否则负责的交互关系会使底层出现问题的时候产生不可预测的对高级抽象的影响，以及加大了抽象修改的难度<br>所以从底层一步步向上理解学习吧，才能有更扎实的基础</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>使用变异(mutating)操作会修改可变对象<br>对于可变对象，关联名称不是创建副本，而是绑定到同一个对象上：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits = chinese</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits.pop()</span><br><span class="line"><span class="string">&#x27;monkey&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>]</span><br></pre></td></tr></table></figure></p><p>创建副本的方法：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nest = <span class="built_in">list</span>(suits)</span><br></pre></td></tr></table></figure></p><p>判断两个对象是否是同一个，用<code>is</code>或<code>is not</code>，判读是否相等用<code>==</code></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>不可变对象</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>描述性检索的数据抽象</p><p>dict()可以将键值对列表转化为字典：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="number">3</span>, <span class="number">9</span>), (<span class="number">4</span>, <span class="number">16</span>), (<span class="number">5</span>, <span class="number">25</span>)])</span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure></p><p>可以用推导式语法创建：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure></p><p>方法：</p><ul><li>get(key,default_value)    return the value if key exist or default value</li><li>items()                   return key and value that is iterable</li><li>values()                  return iterable values</li><li>keys()                    …………….keys</li></ul><h3 id="局部状态"><a href="#局部状态" class="headerlink" title="局部状态"></a>局部状态</h3><p>对函数可变数据的构建用的是nonlocal —— 用于将数据置为非局部状态<br><strong>python限制一个名称对应的实例必须绑定在同一个局部帧中，所以不存在两个帧使用同一个名称的情况</strong><br>查找非局部帧的值不需要非局部语句，修改需要<br>python预处理名称来限制绑定的帧只能在局部帧，所以不允许提前引用变量  </p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>非局部赋值实际上是将balance与with_draw单独绑定，便于各个函数独立分治自己的局部状态<br>创建一个实例就对应创建一个绑定<br>所以引出了一个问题：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line"><span class="number">2</span>    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line"><span class="number">3</span>        <span class="keyword">nonlocal</span> balance</span><br><span class="line"><span class="number">4</span>        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line"><span class="number">5</span>            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line"><span class="number">6</span>        balance = balance - amount</span><br><span class="line"><span class="number">7</span>        <span class="keyword">return</span> balance</span><br><span class="line"><span class="number">8</span>    <span class="keyword">return</span> withdraw</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span>wd = make_withdraw(<span class="number">12</span>)</span><br><span class="line"><span class="number">11</span>wd2 = wd</span><br><span class="line"><span class="number">12</span>wd2(<span class="number">1</span>)</span><br><span class="line"><span class="number">13</span>wd(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>两个相同的名称连接到一个绑定上，所处的帧并没有改变，<strong>只有函数调用才会创建新帧</strong></p><h4 id="实现列表和字典结构"><a href="#实现列表和字典结构" class="headerlink" title="实现列表和字典结构"></a>实现列表和字典结构</h4><p>使用非局部状态函数可以实现可变数据类型，因为非局部帧相当于提供使数据可变的能力，既不帧提供操作数据的方法<br>用函数来作为可变数据结构<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mutable_link</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回一个可变链表的函数&quot;&quot;&quot;</span></span><br><span class="line">        contents = empty</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">message, value=<span class="literal">None</span></span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> contents</span><br><span class="line">            <span class="keyword">if</span> message == <span class="string">&#x27;len&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> len_link(contents)</span><br><span class="line">            <span class="keyword">elif</span> message == <span class="string">&#x27;getitem&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> getitem_link(contents, value)</span><br><span class="line">            <span class="keyword">elif</span> message == <span class="string">&#x27;push_first&#x27;</span>:</span><br><span class="line">                contents = link(value, contents)</span><br><span class="line">            <span class="keyword">elif</span> message == <span class="string">&#x27;pop_first&#x27;</span>:</span><br><span class="line">                f = first(contents)</span><br><span class="line">                contents = rest(contents)</span><br><span class="line">                <span class="keyword">return</span> f</span><br><span class="line">            <span class="keyword">elif</span> message == <span class="string">&#x27;str&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> join_link(contents, <span class="string">&quot;, &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">to_mutable_link</span>(<span class="params">source</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回一个与原列表相同内容的函数列表&quot;&quot;&quot;</span></span><br><span class="line">        s = mutable_link()</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="built_in">reversed</span>(source):</span><br><span class="line">            s(<span class="string">&#x27;push_first&#x27;</span>, element)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><br>可以用两种方法来实现对数据类型的变异操作：</p><ul><li>将方法放到一个局部帧中</li><li>将方法放到不同局部帧中，提供一个消息接口来调用(消息传递)</li></ul><p>消息传递的实现可以模拟一个send_message的过程</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">dictionary</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回一个字典的函数实现&quot;&quot;&quot;</span></span><br><span class="line">        records = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getitem</span>(<span class="params">key</span>):</span><br><span class="line">            matches = [r <span class="keyword">for</span> r <span class="keyword">in</span> records <span class="keyword">if</span> r[<span class="number">0</span>] == key]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(matches) == <span class="number">1</span>:</span><br><span class="line">                key, value = matches[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">setitem</span>(<span class="params">key, value</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> records</span><br><span class="line">            non_matches = [r <span class="keyword">for</span> r <span class="keyword">in</span> records <span class="keyword">if</span> r[<span class="number">0</span>] != key]</span><br><span class="line">            records = non_matches + [[key, value]]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">message, key=<span class="literal">None</span>, value=<span class="literal">None</span></span>):</span><br><span class="line">            <span class="keyword">if</span> message == <span class="string">&#x27;getitem&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> getitem(key)</span><br><span class="line">            <span class="keyword">elif</span> message == <span class="string">&#x27;setitem&#x27;</span>:</span><br><span class="line">                setitem(key, value)</span><br><span class="line">        <span class="keyword">return</span> dispatch</span><br></pre></td></tr></table></figure><h3 id="声明式编程实践：约束传递-Propagating-Constraints"><a href="#声明式编程实践：约束传递-Propagating-Constraints" class="headerlink" title="声明式编程实践：约束传递(Propagating Constraints)"></a>声明式编程实践：约束传递(Propagating Constraints)</h3><p>声明式编程的特性是声明要解决的问题的结构<br>编程中的表达式的计算都是单项的，要实现多项的解方程求值要用变量关系的约束器(Constrainter)和提醒其他约束器的连接器(connector)构成网络<br>使用消息传递以及对消息进行响应的数据结构(类)来构建网络</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>connector [<span class="string">&#x27;set_val&#x27;</span>](source, value)  <span class="string">&quot;&quot;&quot;表示 source 在请求连接器将当前值设为 value&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>connector [<span class="string">&#x27;has_val&#x27;</span>]()  <span class="string">&quot;&quot;&quot;返回连接器是否已经具有值&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>connector [<span class="string">&#x27;val&#x27;</span>]  <span class="string">&quot;&quot;&quot;是连接器的当前值&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>connector [<span class="string">&#x27;forget&#x27;</span>](source)  <span class="string">&quot;&quot;&quot;告诉连接器 source 请求遗忘它的值&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>connector [<span class="string">&#x27;connect&#x27;</span>](source)  <span class="string">&quot;&quot;&quot;告诉连接器参与新的约束，即 source&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>constraint[<span class="string">&#x27;new_val&#x27;</span>]()  <span class="string">&quot;&quot;&quot;表示与约束相连的某个连接器具有新的值。&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>constraint[<span class="string">&#x27;forget&#x27;</span>]()  <span class="string">&quot;&quot;&quot;表示与约束相连的某个连接器遗忘了值。&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">converter</span>(<span class="params">c, f</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;用约束条件连接 c 到 f ，将摄氏度转换为华氏度.&quot;&quot;&quot;</span></span><br><span class="line">        u, v, w, x, y = [connector() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">        multiplier(c, w, u)</span><br><span class="line">        multiplier(v, x, u)</span><br><span class="line">        adder(v, y, f)</span><br><span class="line">        constant(w, <span class="number">9</span>)</span><br><span class="line">        constant(x, <span class="number">5</span>)</span><br><span class="line">        constant(y, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add, sub</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;约束a+b=c&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> make_ternary_constraint(a, b, c, add, sub, sub)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">constant</span>(<span class="params">connector, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;常量赋值.&quot;&quot;&quot;</span></span><br><span class="line">        constraint = &#123;&#125;</span><br><span class="line">        connector[<span class="string">&#x27;set_val&#x27;</span>](constraint, value)</span><br><span class="line">        <span class="keyword">return</span> constraint</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">make_ternary_constraint</span>(<span class="params">a, b, c, ab, ca, cb</span>):       <span class="comment">#不存储连接的连接器，只提供功能</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;约束ab(a,b)=c，ca(c,a)=b，cb(c,b)=a。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">new_value</span>():</span><br><span class="line">            av, bv, cv = [connector[<span class="string">&#x27;has_val&#x27;</span>]() <span class="keyword">for</span> connector <span class="keyword">in</span> (a, b, c)]</span><br><span class="line">            <span class="keyword">if</span> av <span class="keyword">and</span> bv:</span><br><span class="line">                c[<span class="string">&#x27;set_val&#x27;</span>](constraint, ab(a[<span class="string">&#x27;val&#x27;</span>], b[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line">            <span class="keyword">elif</span> av <span class="keyword">and</span> cv:</span><br><span class="line">                b[<span class="string">&#x27;set_val&#x27;</span>](constraint, ca(c[<span class="string">&#x27;val&#x27;</span>], a[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line">            <span class="keyword">elif</span> bv <span class="keyword">and</span> cv:</span><br><span class="line">                a[<span class="string">&#x27;set_val&#x27;</span>](constraint, cb(c[<span class="string">&#x27;val&#x27;</span>], b[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">forget_value</span>():</span><br><span class="line">            <span class="keyword">for</span> connector <span class="keyword">in</span> (a, b, c):</span><br><span class="line">                connector[<span class="string">&#x27;forget&#x27;</span>](constraint)</span><br><span class="line">        constraint = &#123;<span class="string">&#x27;new_val&#x27;</span>: new_value, <span class="string">&#x27;forget&#x27;</span>: forget_value&#125;</span><br><span class="line">        <span class="keyword">for</span> connector <span class="keyword">in</span> (a, b, c):</span><br><span class="line">            connector[<span class="string">&#x27;connect&#x27;</span>](constraint)</span><br><span class="line">        <span class="keyword">return</span> constraint</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">connector</span>(<span class="params">name=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;限制条件之间的连接器.&quot;&quot;&quot;</span></span><br><span class="line">        informant = <span class="literal">None</span></span><br><span class="line">        constraints = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">source, value</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> informant</span><br><span class="line">            val = connector[<span class="string">&#x27;val&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                informant, connector[<span class="string">&#x27;val&#x27;</span>] = source, value</span><br><span class="line">                <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="built_in">print</span>(name, <span class="string">&#x27;=&#x27;</span>, value)</span><br><span class="line">                inform_all_except(source, <span class="string">&#x27;new_val&#x27;</span>, constraints)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> val != value:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;Contradiction detected:&#x27;</span>, val, <span class="string">&#x27;vs&#x27;</span>, value)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">forget_value</span>(<span class="params">source</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> informant</span><br><span class="line">            <span class="keyword">if</span> informant == source:</span><br><span class="line">                informant, connector[<span class="string">&#x27;val&#x27;</span>] = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="built_in">print</span>(name, <span class="string">&#x27;is forgotten&#x27;</span>)</span><br><span class="line">                inform_all_except(source, <span class="string">&#x27;forget&#x27;</span>, constraints)</span><br><span class="line">        connector = &#123;<span class="string">&#x27;val&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">                     <span class="string">&#x27;set_val&#x27;</span>: set_value,</span><br><span class="line">                     <span class="string">&#x27;forget&#x27;</span>: forget_value,</span><br><span class="line">                     <span class="string">&#x27;has_val&#x27;</span>: <span class="keyword">lambda</span>: connector[<span class="string">&#x27;val&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>,</span><br><span class="line">                     <span class="string">&#x27;connect&#x27;</span>: <span class="keyword">lambda</span> source: constraints.append(source)&#125;</span><br><span class="line">        <span class="keyword">return</span> connector</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">inform_all_except</span>(<span class="params">source, message, constraints</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;告知信息除了source外的所有约束条件，。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> constraints:</span><br><span class="line">            <span class="keyword">if</span> c != source:</span><br><span class="line">                c[message]()</span><br></pre></td></tr></table></figure><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>类的构造器：<code>__init__</code><br><code>self</code>绑定对象，调用时实例会绑定到self中<br>赋值将对象绑定到新名称不会创建新对象:<br><code>c = a</code><br>作为类的属性，方法只是一个函数，但作为实例的属性，它是一个绑定方法：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;Function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(spock_account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;method&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p><p>我们可以通过两种方式调用 deposit ：作为函数和作为绑定方法。在前一种情况下，我们必须显式地为 self 参数提供一个参数。在后一种情况下， self 参数会自动绑定。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.deposit(spock_account, <span class="number">1001</span>)<span class="comment"># 函数 deposit 接受两个参数</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">1000</span>) <span class="comment"># 方法 deposit 接受一个参数</span></span><br><span class="line"><span class="number">2011</span></span><br></pre></td></tr></table></figure></p><p>如果属性名称以下划线开头，则只能在类中本地访问，不能被用户访问</p><p><strong>类属性</strong>是所有实例共享的静态变量</p><p>对象的点表达式，如果是实例，存在则调用，不存在则创建，但是不会访问类属性，只有对类的调点表达式才会修改类属性<br>同名时，本地的实例属性是优先于类属性的</p><p>baseclass, superclass, parentclass<br>subclass, childclass</p><p>接受参数作为父类，重写属性或者方法，注意父类中对实例属性的调用最好都用self.attr，方便作继承</p><p>尽量不要使用Account.method，使用实例的方法更具普遍性</p><p><strong>重写</strong>：方法可以重写，注意最后好使用self.attribution来在类中定义属性或方法，因为在该类的子类中继承此方法，要使用的是子类的新值</p><p><strong>多继承</strong>：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">AsSeenOnTVAccount</span>(CheckingAccount, SavingsAccount):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            self.balance = <span class="number">1</span>           <span class="comment"># 赠送的 1 $!</span></span><br></pre></td></tr></table></figure><br>对于多继承，调用不同类的同一个名称的方法时，检索顺序为从左到右，从子到基<br>查看解析对于类和属性的查询顺序：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[c.__name__ <span class="keyword">for</span> c <span class="keyword">in</span> AsSeenOnTVAccount.mro()]</span><br><span class="line">[<span class="string">&#x27;AsSeenOnTVAccount&#x27;</span>, <span class="string">&#x27;CheckingAccount&#x27;</span>, <span class="string">&#x27;SavingsAccount&#x27;</span>, <span class="string">&#x27;Account&#x27;</span>, <span class="string">&#x27;object&#x27;</span>]</span><br></pre></td></tr></table></figure></p><h3 id="使用函数来实现类"><a href="#使用函数来实现类" class="headerlink" title="使用函数来实现类"></a>使用函数来实现类</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">make_instance</span>(<span class="params">cls</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;Return a new object instance, which is a dispatch dictionary.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">name</span>):</span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">in</span> attributes:</span><br><span class="line"><span class="keyword">return</span> attributes[name]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">value = cls[<span class="string">&#x27;get&#x27;</span>](name)</span><br><span class="line"><span class="keyword">return</span> bind_method(value, instance)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">name, value</span>):</span><br><span class="line">attributes[name] = value</span><br><span class="line">attributes = &#123;&#125;</span><br><span class="line">instance = &#123;<span class="string">&#x27;get&#x27;</span>: get_value, <span class="string">&#x27;set&#x27;</span>: set_value&#125;</span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">bind_method</span>(<span class="params">value, instance</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;Return a bound method if is callable, or value otherwise.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">callable</span>(value):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">*args</span>):</span><br><span class="line"><span class="keyword">return</span> value(instance, *args)</span><br><span class="line"><span class="keyword">return</span> method</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>使用响应消息的调度字典来实现，如果获取到的name在attribute中找不到，则进入bind_method来寻找以及绑定类和方法，找到了是函数的话，返回使用alue的函数，并且将instance作为self</p><h3 id="专用方法"><a href="#专用方法" class="headerlink" title="专用方法"></a>专用方法</h3><ul><li><code>__repr__</code>在使用交互环境时自动调用  </li><li><code>__str__</code>在打印时自动调用  </li><li><code>__bool__</code>构造，可以判断逻辑时自动调用  </li><li><code>__len__</code>长度，使用len()时调用  </li><li><code>__getitem__</code>，获取元素时调用  </li><li><code>__call__</code>可以使类可以像高阶函数一样被传播调用  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Adder</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">self.n = n</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, k</span>):</span><br><span class="line"><span class="keyword">return</span> self.n + k</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three_obj = Adder(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three_obj(<span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="多重表示"><a href="#多重表示" class="headerlink" title="多重表示"></a>多重表示</h3><p>接口是一组共享的属性名称，以及对它们的行为的规范<br>从最高层抽象向下实现：数值类型——拥有的操作——具体属性定义<br>Complex实现了接口，保证了具体方法的属性的一致性，达成了命名规范<br>@property修饰符可以将函数变为无参数，直接当属性值使用<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line"><span class="keyword">return</span> self.add(other)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line"><span class="keyword">return</span> self.mul(other)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Complex</span>(<span class="title class_ inherited__">Number</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, other</span>):</span><br><span class="line"><span class="keyword">return</span> ComplexRI(self.real + other.real, self.imag + other.imag)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self, other</span>):</span><br><span class="line">magnitude = self.magnitude * other.magnitude</span><br><span class="line"><span class="keyword">return</span> ComplexMA(magnitude, self.angle + other.angle)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> atan2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ComplexRI</span>(<span class="title class_ inherited__">Complex</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, real, imag</span>):</span><br><span class="line">self.real = real</span><br><span class="line">self.imag = imag</span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">magnitude</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> (self.real ** <span class="number">2</span> + self.imag ** <span class="number">2</span>) ** <span class="number">0.5</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angle</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> atan2(self.imag, self.real)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;ComplexRI(&#123;0:g&#125;, &#123;1:g&#125;)&#x27;</span>.<span class="built_in">format</span>(self.real, self.imag)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos, pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ComplexMA</span>(<span class="title class_ inherited__">Complex</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, magnitude, angle</span>):</span><br><span class="line">self.magnitude = magnitude</span><br><span class="line">self.angle = angle</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">real</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.magnitude * cos(self.angle)</span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imag</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.magnitude * sin(self.angle)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;ComplexMA(&#123;0:g&#125;, &#123;1:g&#125; * pi)&#x27;</span>.<span class="built_in">format</span>(self.magnitude, self.angle/pi)</span><br></pre></td></tr></table></figure></p><p>优势：<br>类似complex的接口类是可以开发添加的</p><h3 id="泛型表示"><a href="#泛型表示" class="headerlink" title="泛型表示"></a>泛型表示</h3><h4 id="类型派发"><a href="#类型派发" class="headerlink" title="类型派发"></a>类型派发</h4><p>依据受到的参数的类型(类的种类)来派发响应，保证数据跨类型的时候仍然可以被正确地对待</p><p>内置的函数 isinstance 接受一个对象或一个类。如果对象的类是所给的类或者继承自所给的类，它会返回一个真值<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ComplexRI(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, ComplexRI)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Complex)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, ComplexMA)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p><p>基于不同类型的接口类一个type_tag，来在进行操作的时候检查type_tag来进行类型派发<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line"><span class="keyword">if</span> self.type_tag == other.type_tag:</span><br><span class="line"><span class="keyword">return</span> self.add(other)</span><br><span class="line"><span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.adders:</span><br><span class="line"><span class="keyword">return</span> self.cross_apply(other, self.adders)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line"><span class="keyword">if</span> self.type_tag == other.type_tag:</span><br><span class="line"><span class="keyword">return</span> self.mul(other)</span><br><span class="line"><span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.multipliers:</span><br><span class="line"><span class="keyword">return</span> self.cross_apply(other, self.multipliers)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross_apply</span>(<span class="params">self, other, cross_fns</span>):</span><br><span class="line">cross_fn = cross_fns[(self.type_tag, other.type_tag)]</span><br><span class="line"><span class="keyword">return</span> cross_fn(self, other)</span><br><span class="line">adders = &#123;(<span class="string">&quot;com&quot;</span>, <span class="string">&quot;rat&quot;</span>): add_complex_and_rational,</span><br><span class="line">(<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;com&quot;</span>): add_rational_and_complex&#125;</span><br><span class="line">multipliers = &#123;(<span class="string">&quot;com&quot;</span>, <span class="string">&quot;rat&quot;</span>): mul_complex_and_rational,</span><br><span class="line">(<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;com&quot;</span>): mul_rational_and_complex&#125;</span><br></pre></td></tr></table></figure></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将一种数据类型和另一种数据类型在符合某种条件时可以实施强制类型转换来简化操作<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">x, y = self.coerce(other)</span><br><span class="line"><span class="keyword">return</span> x.add(y)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">x, y = self.coerce(other)</span><br><span class="line"><span class="keyword">return</span> x.mul(y)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coerce</span>(<span class="params">self, other</span>):</span><br><span class="line"><span class="keyword">if</span> self.type_tag == other.type_tag:</span><br><span class="line"><span class="keyword">return</span> self, other</span><br><span class="line"><span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.coercions:</span><br><span class="line"><span class="keyword">return</span> (self.coerce_to(other.type_tag), other)</span><br><span class="line"><span class="keyword">elif</span> (other.type_tag, self.type_tag) <span class="keyword">in</span> self.coercions:</span><br><span class="line"><span class="keyword">return</span> (self, other.coerce_to(self.type_tag))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coerce_to</span>(<span class="params">self, other_tag</span>):</span><br><span class="line">coercion_fn = self.coercions[(self.type_tag, other_tag)]</span><br><span class="line"><span class="keyword">return</span> coercion_fn(self)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">rational_to_complex</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="keyword">return</span> ComplexRI(r.numer/r.denom, <span class="number">0</span>)</span><br><span class="line">coercions = &#123;(<span class="string">&#x27;rat&#x27;</span>, <span class="string">&#x27;com&#x27;</span>): rational_to_complex&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>可以用记忆化来提前存储值：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">memo</span>(<span class="params">f</span>):</span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">memorized</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">                cache[n] = f(n)</span><br><span class="line">            <span class="keyword">return</span> cache[n]</span><br><span class="line">        <span class="keyword">return</span> memorized</span><br></pre></td></tr></table></figure></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">f</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">counted</span>(<span class="params">n</span>):</span><br><span class="line">            counted.call_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> f(n)</span><br><span class="line">        counted.call_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> counted</span><br></pre></td></tr></table></figure><p>这种方式可以构造类似于类的属性值，作为外部变量来使用<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = count(fib)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">19</span>)</span><br><span class="line"><span class="number">4181</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib.call_count</span><br><span class="line"><span class="number">10946</span></span><br></pre></td></tr></table></figure></p><p>阶乘的时间复杂度 $\Theta(\log_{2}{n})$ 的优化  </p><script type="math/tex; mode=display">b^{n}=\begin{cases}(b^{\frac{n}{2}})^{2}\qquad\qquad 如果n是偶数\\ b\cdot{b^{n-1}}\qquad\quad 如果n是奇数\end{cases}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fast_exp</span>(<span class="params">b, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> square(fast_exp(b, n // <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> b * fast_exp(b, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fast_exp(<span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"><span class="number">1267650600228229401496703205376</span></span><br></pre></td></tr></table></figure><p>python中的<code>if in</code>是有n的时间复杂度的</p><p>feibonaqi数列最接近黄金比例的n-2次方除以根号5</p><h2 id="递归对象"><a href="#递归对象" class="headerlink" title="递归对象"></a>递归对象</h2><p>可以使用类方法的递归来构建诸如<strong>链表、树、集合</strong>的数据结构，以及<strong>add、repr</strong>等方法，和很多操作，其本质和递归函数是一样的，可以用<code>Link.__add__ = extend</code>来直接进行专用方法赋值，具体方法如下：</p><p>链表<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Link</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;一个链表&quot;&quot;&quot;</span></span><br><span class="line">        empty = ()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, rest=(<span class="params"></span>)</span>):</span><br><span class="line">            <span class="keyword">assert</span> rest == Link.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(rest, Link)</span><br><span class="line">            self.first = first</span><br><span class="line">            self.rest = rest</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.first</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.rest[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">len</span>(self.rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">link_expression</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回一个可以计算得到 s 的字符串表达式。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">            rest = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rest = <span class="string">&#x27;, &#x27;</span> + link_expression(s.rest)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Link(&#123;0&#125;&#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(s.first, rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>link_expression(s)</span><br><span class="line"><span class="string">&#x27;Link(3, Link(4, Link(5)))&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Link.__repr__ = link_expression</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_first = Link(s, Link(<span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_first</span><br><span class="line">Link(Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>))), Link(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s_first)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s_first[<span class="number">0</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_first[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">extend_link</span>(<span class="params">s, t</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> t</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(s.first, extend_link(s.rest, t))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extend_link(s, s)</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>))))))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Link.__add__ = extend_link</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s + s</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>))))))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">map_link</span>(<span class="params">f, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(f(s.first), map_link(f, s.rest))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_link(square, s)</span><br><span class="line">Link(<span class="number">9</span>, Link(<span class="number">16</span>, Link(<span class="number">25</span>)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">filter_link</span>(<span class="params">f, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            filtered = filter_link(f, s.rest)</span><br><span class="line">            <span class="keyword">if</span> f(s.first):</span><br><span class="line">                <span class="keyword">return</span> Link(s.first, filtered)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> filtered</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd = <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_link(square, filter_link(odd, s))</span><br><span class="line">Link(<span class="number">9</span>, Link(<span class="number">25</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[square(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="keyword">if</span> odd(x)]</span><br><span class="line">[<span class="number">9</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">join_link</span>(<span class="params">s, separator</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(s.first)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(s.first) + separator + join_link(s.rest, separator)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join_link(s, <span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="string">&#x27;3, 4, 5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">partitions</span>(<span class="params">n, m</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a linked list of partitions of n using parts of up to m.</span></span><br><span class="line"><span class="string">        Each partition is represented as a linked list.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(Link.empty) <span class="comment"># A list containing the empty partition</span></span><br><span class="line">        <span class="keyword">elif</span> n &lt; <span class="number">0</span> <span class="keyword">or</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Link.empty</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            using_m = partitions(n-m, m)</span><br><span class="line">            with_m = map_link(<span class="keyword">lambda</span> s: Link(m, s), using_m)</span><br><span class="line">            without_m = partitions(n, m-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> with_m + without_m</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_partitions</span>(<span class="params">n, m</span>):</span><br><span class="line">        lists = partitions(n, m)</span><br><span class="line">        strings = map_link(<span class="keyword">lambda</span> s: join_link(s, <span class="string">&quot; + &quot;</span>), lists)</span><br><span class="line">        <span class="built_in">print</span>(join_link(strings, <span class="string">&quot;\n&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_partitions(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">4</span> + <span class="number">2</span></span><br><span class="line"><span class="number">4</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">3</span></span><br><span class="line"><span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span> + <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="number">2</span> + <span class="number">2</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>树：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, label, branches=(<span class="params"></span>)</span>):</span><br><span class="line">            self.label = label</span><br><span class="line">            <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(branch, Tree)</span><br><span class="line">            self.branches = branches</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">if</span> self.branches:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Tree(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.label, <span class="built_in">repr</span>(self.branches))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Tree(&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.label))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> self.branches</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Tree(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> Tree(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = fib_tree(n-<span class="number">2</span>)</span><br><span class="line">            right = fib_tree(n-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Tree(left.label + right.label, (left, right))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib_tree(<span class="number">5</span>)</span><br><span class="line">Tree(<span class="number">3</span>, (Tree(<span class="number">1</span>, (Tree(<span class="number">0</span>), Tree(<span class="number">1</span>))), Tree(<span class="number">2</span>, (Tree(<span class="number">1</span>), Tree(<span class="number">1</span>, (Tree(<span class="number">0</span>), Tree(<span class="number">1</span>)))))))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_labels</span>(<span class="params">t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;对树的 label 求和，可能得到 None。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> t.label + <span class="built_in">sum</span>([sum_labels(b) <span class="keyword">for</span> b <span class="keyword">in</span> t.branches])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_labels(fib_tree(<span class="number">5</span>))</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib_tree = memo(fib_tree)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_fib_tree = fib_tree(<span class="number">35</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_fib_tree.label</span><br><span class="line"><span class="number">5702887</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_fib_tree.branches[<span class="number">0</span>] <span class="keyword">is</span> big_fib_tree.branches[<span class="number">1</span>].branches[<span class="number">1</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_labels = memo(sum_labels)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_labels(big_fib_tree)</span><br><span class="line"><span class="number">142587180</span></span><br></pre></td></tr></table></figure></p><p>集合：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.union(&#123;<span class="number">1</span>, <span class="number">5</span>&#125;)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.intersection(&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;)</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">is</span> Link.empty</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;当且仅当 set s 包含 v 时返回 True。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> empty(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.first == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.rest, v)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(s, <span class="number">2</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(s, <span class="number">5</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">adjoin_set</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回一个包含 s 的所有元素和元素 v 的所有元素的集合。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> set_contains(s, v):</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(v, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = adjoin_set(s, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">Link(<span class="number">2</span>, Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>))))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">union_set</span>(<span class="params">set1, set2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回一个集合，包含 set1 和 set2 中的所有元素。&quot;&quot;&quot;</span></span><br><span class="line">        set1_not_set2 = keep_if_link(set1, <span class="keyword">lambda</span> v: <span class="keyword">not</span> set_contains(set2, v))</span><br><span class="line">        <span class="keyword">return</span> extend_link(set1_not_set2, set2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>union_set(t, s)</span><br><span class="line">Link(<span class="number">2</span>, Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>))))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> empty(s) <span class="keyword">or</span> s.first &gt; v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.first == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.rest, v)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = Link(<span class="number">1</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(u, <span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(u, <span class="number">4</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">intersect_set</span>(<span class="params">set1, set2</span>):</span><br><span class="line">        <span class="keyword">if</span> empty(set1) <span class="keyword">or</span> empty(set2):</span><br><span class="line">            <span class="keyword">return</span> Link.empty</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            e1, e2 = set1.first, set2.first</span><br><span class="line">            <span class="keyword">if</span> e1 == e2:</span><br><span class="line">                <span class="keyword">return</span> Link(e1, intersect_set(set1.rest, set2.rest))</span><br><span class="line">            <span class="keyword">elif</span> e1 &lt; e2:</span><br><span class="line">                <span class="keyword">return</span> intersect_set(set1.rest, set2)</span><br><span class="line">            <span class="keyword">elif</span> e2 &lt; e1:</span><br><span class="line">                <span class="keyword">return</span> intersect_set(set1, set2.rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intersect_set(s, s.rest)</span><br><span class="line">Link(<span class="number">4</span>, Link(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.entry == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> s.entry &lt; v:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.right, v)</span><br><span class="line">        <span class="keyword">elif</span> s.entry &gt; v:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.left, v)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">adjoin_set</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> Tree(v)</span><br><span class="line">        <span class="keyword">elif</span> s.entry == v:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">elif</span> s.entry &lt; v:</span><br><span class="line">            <span class="keyword">return</span> Tree(s.entry, s.left, adjoin_set(s.right, v))</span><br><span class="line">        <span class="keyword">elif</span> s.entry &gt; v:</span><br><span class="line">            <span class="keyword">return</span> Tree(s.entry, adjoin_set(s.left, v), s.right)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adjoin_set(adjoin_set(adjoin_set(<span class="literal">None</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line">Tree(<span class="number">2</span>, Tree(<span class="number">1</span>), Tree(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>为了不预先存储值，但是能动态生成所要的数据或者操作，使用惰态计算，给予时延<br>iterator使用next返回下一个值，当没有值时返回StopIteration<br>迭代器用iter构造可迭代对象为迭代器，iter本身也可以被使用iter方法，作用是绑定名称        </p><p>map 函数是惰性的：调用它时并不会执行计算，直到返回的迭代器被 next 调用<br>相反，会创建一个迭代器对象，如果使用 next 查询， 该迭代器对象可以返回结果。我们可以在下面的示例中观察到这一事实，其中对 print 的调用被 延迟，直到从 doubled 迭代器请求相应的元素为止。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">double_and_print</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;***&#x27;</span>, x, <span class="string">&#x27;=&gt;&#x27;</span>, <span class="number">2</span>*x, <span class="string">&#x27;***&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doubled = <span class="built_in">map</span>(double_and_print, s)  <span class="comment"># double_and_print 未被调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(doubled)                       <span class="comment"># double_and_print 调用一次</span></span><br><span class="line">*** <span class="number">3</span> =&gt; <span class="number">6</span> ***</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(doubled)                       <span class="comment"># double_and_print 再次调用</span></span><br><span class="line">*** <span class="number">4</span> =&gt; <span class="number">8</span> ***</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(doubled)                       <span class="comment"># double_and_print 再次调用兩次</span></span><br><span class="line">*** <span class="number">5</span> =&gt; <span class="number">10</span> ***                         <span class="comment"># list() 会把剩余的值都计算出来并生成一个列表</span></span><br><span class="line">*** <span class="number">6</span> =&gt; <span class="number">12</span> ***</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><br>filter 函数返回一个迭代器， zip 和 reversed 函数也返回迭代器。  </p><p>for循环是调用了可迭代对象本身的<strong>iter</strong>方法，返回next值给绑定值，然后执行\<suite>主体部分<br>构造for循环：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = counts.__iter__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">             item = items.__next__()</span><br><span class="line">             <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></suite></p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器是一种迭代器，为了控制迭代函数的进度，使用生成器，关键词为yield，当函数内有yield关键词时，默认返回一个生成器，每次next返回下一个yield对应的值</p><h3 id="可迭代接口"><a href="#可迭代接口" class="headerlink" title="可迭代接口"></a>可迭代接口</h3><p>可以使类的<strong>iter</strong>方法返回一个迭代器，但是类本身是不变的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Letters</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">&#x27;a&#x27;</span>, end=<span class="string">&#x27;e&#x27;</span></span>):</span><br><span class="line">            self.start = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> LetterIter(self.start, self.end)</span><br></pre></td></tr></table></figure></p><p>自定义迭代器，next方法，使用next时调用：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">LetterIter</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;依照 ASCII 码值顺序迭代字符的迭代器。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">&#x27;a&#x27;</span>, end=<span class="string">&#x27;e&#x27;</span></span>):</span><br><span class="line">            self.next_letter = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">if</span> self.next_letter == self.end:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line">            letter = self.next_letter</span><br><span class="line">            self.next_letter = <span class="built_in">chr</span>(<span class="built_in">ord</span>(letter)+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> letter</span><br></pre></td></tr></table></figure></p><h3 id="流：惰性递归"><a href="#流：惰性递归" class="headerlink" title="流：惰性递归"></a>流：惰性递归</h3><p>Stream是一种对递归使用惰性的方法，不会提前计算下一个递归结果是什么，除非手动调用它<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Stream(<span class="number">1</span>, <span class="keyword">lambda</span>: Stream(<span class="number">2</span>+<span class="number">3</span>, <span class="keyword">lambda</span>: Stream.empty))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Stream</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A lazily computed recursive list.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, compute_rest, empty=<span class="literal">False</span></span>):</span><br><span class="line">            self.first = first</span><br><span class="line">            self._compute_rest = compute_rest</span><br><span class="line">            self.empty = empty</span><br><span class="line">            self._rest = <span class="literal">None</span></span><br><span class="line">            self._computed = <span class="literal">False</span></span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">rest</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Return the rest of the stream, computing it if necessary.&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">not</span> self.empty, <span class="string">&#x27;Empty streams have no rest.&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._computed:</span><br><span class="line">                self._rest = self._compute_rest()</span><br><span class="line">                self._computed = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> self._rest</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">if</span> self.empty:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&lt;empty stream&gt;&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Stream(&#123;0&#125;, &lt;compute_rest&gt;)&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.first))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stream.empty = Stream(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><p>可以修改定义map函数或者filter函数，使map功能可以给流的每个递归<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">map_stream</span>(<span class="params">fn, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">compute_rest</span>():</span><br><span class="line">            <span class="keyword">return</span> map_stream(fn, s.rest)</span><br><span class="line">        <span class="keyword">return</span> Stream(fn(s.first), compute_rest)</span><br></pre></td></tr></table></figure></p><h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>compiler编译器：编译为底层语言供机器识别<br>interpreter解释器：将一种语言解释为另一种语言，python的解释器就是用c写的，因为解释器是按照每一行来读取输入的，所以解释器是行解释的  </p><p>对一个语言的解释：</p><ul><li>词法解析(lexical analyzer)：使用分词器将语法分为标记(token)，之后传给语法解析器</li><li>语法解析(syntactic analyzer)：对标记使用可递归的数据结构来构架语法树</li><li>计算(calculate)：对语法树进行计算，计算面向的是递归的数据结构</li></ul><h2 id="语法杂记"><a href="#语法杂记" class="headerlink" title="语法杂记"></a>语法杂记</h2><p>定义函数参数给出后视作默认值，使用时可以不写</p><p>文档字符串，三个双引号，使用help(fun)查看</p><p>元组的加与乘返回结果是组合以后的元组，map函数可将函数应用于数据，reduce可以将函数作用于序列返回单值(归约)，tuple可以将数据类型变为元组</p><p>python对变量的定义是非严格的，所以想要在函数内使用父帧的变量要进行声明，否则默认为局部帧的新变量<br>声明方法有<code>nonlocal</code>(嵌套函数)和<code>global</code>(全局)</p><p>is和is not用于判断两个对像是否相同，这个相同指的是相同的内存地址</p><p>强制类型转换，类型不加括号</p><p>print(‘a’),打印：a</p><p>and运算时，从左到右演算表达式的值。0, ‘’, [], {}, None在布尔表达式环境下为假，其他任何东西都为真，返回作后一个真值或假值<br>or返回最后一个真值或最后一个假值<br>not 10 返回False， not None 返回True   注意0是真值,但是not 0中0为假<br>1/0 or True 为Error，从左到右判断，遇到Error直接Error</p><p>元组元素不可修改</p><p>assert用法：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="built_in">type</span>(sides) == <span class="built_in">int</span> <span class="keyword">and</span> sides &gt;= <span class="number">1</span>, <span class="string">&#x27;Illegal value for sides&#x27;</span> </span><br></pre></td></tr></table></figure></p><p>return A if condition else </p><p>.strip()方法消除字符串首尾空白字符</p><p>字典中的in是判断的key值</p><p>random.sample接受list和指定个数，返回列表   一定要注意函数的返回类型</p><p>列表和字符串[1:]没有的时候会返回空，不会报错</p><p>字典可以多对一</p><p>for 迭代变量会自动修正</p><p>del删除列表元素</p><p>生成迭代器：iter()， 下一个next()，对应类的<strong>iter</strong>和<strong>next</strong>方法，迭代器的一个好处是不会和列表一样占用内存空间</p><p>生成器：是一种返回一个值的迭代器，使用yield产生<br>有next方法，send方法<br>生成器函数的调用会返回一个生成器(就像是类和实例)，生成器也就是迭代器，好处是可以暂存挂起当前状态，来节省状态<br>生成器中的return被调用时会抛出报错，当函数中含有yield关键词的时候，这个函数就已经是一个用来返回生成器的道具了，不是一般的函数  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="built_in">type</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)])     <span class="comment">#推导式</span></span><br><span class="line">Out[<span class="number">1</span>]: <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">type</span>((i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)))     <span class="comment">#生成器</span></span><br><span class="line">Out[<span class="number">2</span>]: generator</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常见的使用生成器来实现的斐波那契数列<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/python</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">def fab(max): </span><br><span class="line">    n, a, b = 0, 0, 1 </span><br><span class="line">    while n &lt; max: </span><br><span class="line">        yield b      # 使用 yield</span><br><span class="line">        # print b </span><br><span class="line">        a, b = b, a + b </span><br><span class="line">        n = n + 1</span><br><span class="line"> </span><br><span class="line">for n in fab(5): </span><br><span class="line">    print n</span><br></pre></td></tr></table></figure></p><p>可以用send方法来发送yield的赋值对象，直接赋值会是None，因为从yield处继续开始迭代，所以不会有值<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">   ...:         <span class="built_in">print</span>(<span class="string">&quot;Start...&quot;</span>)</span><br><span class="line">   ...:         receive =  <span class="keyword">yield</span> i</span><br><span class="line">   ...:         <span class="built_in">print</span>(receive)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: f = fun()</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="built_in">next</span>(f)</span><br><span class="line">Start...</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="built_in">next</span>(f)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">Start...</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="built_in">next</span>(f)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">Start...</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: f.send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">hello</span><br><span class="line">Start...</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>对iter调用iter，是同一个迭代器<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">t = <span class="built_in">iter</span>(s)</span><br><span class="line">q = <span class="built_in">iter</span>(t)</span><br></pre></td></tr></table></figure></p><p>close方法可以关闭生成器</p><p>无穷：value = float(‘inf’)</p><p>zip函数：返回可迭代对象元素组成的元组的列表<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = <span class="built_in">zip</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x7f47f15ef040</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(ls)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">path_yielder</span>(<span class="params">t, value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Yields all possible paths from the root of t to a node with the label value</span></span><br><span class="line"><span class="string">    as a list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = Tree(1, [Tree(2, [Tree(3), Tree(4, [Tree(6)]), Tree(5)]), Tree(5)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">          6</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(path_yielder(t1, 6))</span></span><br><span class="line"><span class="string">    [1, 2, 4, 6]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; path_to_5 = path_yielder(t1, 5)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sorted(list(path_to_5))</span></span><br><span class="line"><span class="string">    [[1, 2, 5], [1, 5]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t2 = Tree(0, [Tree(2, [t1])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(t2)</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        1</span></span><br><span class="line"><span class="string">          2</span></span><br><span class="line"><span class="string">            3</span></span><br><span class="line"><span class="string">            4</span></span><br><span class="line"><span class="string">              6</span></span><br><span class="line"><span class="string">            5</span></span><br><span class="line"><span class="string">          5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; path_to_2 = path_yielder(t2, 2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sorted(list(path_to_2))</span></span><br><span class="line"><span class="string">    [[0, 2], [0, 2, 1, 2]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 递归的信仰之越，无关返回类型，只关心现在的判断和下一个关系</span></span><br><span class="line">    <span class="comment">## 生成器遇到return，会停止这一项的yield，但是不会返回值，这题表现为停止一条路径，继续执行下面的yield</span></span><br><span class="line">    <span class="comment">## 因为到叶子节点的时候，path函数是函数，所以返回上一级</span></span><br><span class="line">    <span class="comment">## 抽象思维，先抽象再具象，如果以上来就具象的话会很难完成</span></span><br><span class="line">    <span class="keyword">if</span> t.label == value:</span><br><span class="line">        <span class="keyword">yield</span> [t.label]</span><br><span class="line">    <span class="keyword">elif</span> t.is_leaf():</span><br><span class="line">        <span class="comment">#use return instead of yield! because the road does not exit, so we shouldn&#x27;t yield it</span></span><br><span class="line">        <span class="keyword">return</span> []   </span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> t.branches:</span><br><span class="line">        <span class="keyword">for</span> road <span class="keyword">in</span> path_yielder(b, value):</span><br><span class="line">            <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">            road.insert(<span class="number">0</span>, t.label)</span><br><span class="line">            <span class="keyword">yield</span> road</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_all</span>(<span class="params">link , value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Remove all the nodes containing value in link. Assume that the</span></span><br><span class="line"><span class="string">    first element is never removed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; l1 = Link(0, Link(2, Link(2, Link(3, Link(1, Link(2, Link(3)))))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(l1)</span></span><br><span class="line"><span class="string">    &lt;0 2 2 3 1 2 3&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; remove_all(l1, 2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(l1)</span></span><br><span class="line"><span class="string">    &lt;0 3 1 3&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; remove_all(l1, 3)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(l1)</span></span><br><span class="line"><span class="string">    &lt;0 1&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; remove_all(l1, 3)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(l1)</span></span><br><span class="line"><span class="string">    &lt;0 1&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="comment">#?为什么做起来难度这么大，对于递归要清楚函数的功能，先将函数本身的功能定义好</span></span><br><span class="line">    <span class="keyword">if</span> link <span class="keyword">is</span> Link.empty:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> link.rest <span class="keyword">is</span> Link.empty <span class="keyword">and</span> link.rest.first == value:</span><br><span class="line">        link.rest = link.rest.rest</span><br><span class="line">    remove_all(link.rest, value)</span><br></pre></td></tr></table></figure><p>scheme尾递归：需要新定义函数<br>要存储功能的话就要将存储表作为参数传</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">replicate</span> x n)</span><br><span class="line">  <span class="symbol">&#x27;YOUR-CODE-HERE</span></span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">repl</span> lst x n)</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      lst</span><br><span class="line">      (<span class="name">repl</span> (<span class="name"><span class="built_in">cons</span></span> x lst) x (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>))))</span><br><span class="line">  (<span class="name">repl</span> nil x n)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>又比如：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">accumulate</span> combiner start n term)</span><br><span class="line">  <span class="symbol">&#x27;YOUR-CODE-HERE</span></span><br><span class="line">  (<span class="name"><span class="built_in">begin</span></span></span><br><span class="line">    (<span class="name"><span class="built_in">define</span></span> (<span class="name">acc</span> result combiner start n term)</span><br><span class="line">      (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>)</span><br><span class="line">        result</span><br><span class="line">        (<span class="name">acc</span> (<span class="name">combiner</span> (<span class="name">term</span> start) result) combiner (<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> start) (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>) term)))</span><br><span class="line">    (<span class="name">acc</span> start combiner <span class="number">1</span> n term)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
